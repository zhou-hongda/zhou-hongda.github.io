[{"categories":[],"content":"1，hugo网站的目录结构 config.toml 站点全局的参数配置文件**（包含指定主题对应的各种参数，在这里可以修改网站页面的布局）** archetypes Hugo的markdown文件中前置数据Front Matter定义的结构，默认使用的是default.md文件，可以自定义，然后在config.toml中指定自定义的结构文件，打开default.md文件。至于喜欢哪种格式，可以在config.toml中进行配置，默认使用的是yaml格式。通过执行hugo new 命令生成的markdown文件，头部默认会有这段渲染之后的Front Matter，一般我们会把draft属性去掉，draft草稿的意思，有这个属性的md文件不会渲染输出， 当然通过hugo –buildDrafts可以强制输出。（markdown文章的模版,包括文章前缀注释写法，可以为文章在博客中的导览提供信息） content 存放网页内容的目录，即我们编写的markdown文件都存放在此目录，此目录是Hugo的默认源目录，在E:/website/second-blog下执行命令 hugo new post/hugo_introduce.md之后， 则会在content目录下生成子目录post，post中有一个hugo_introduce.md文件。（文章内容的存放地点，我使用的是loveit主题，会包含一些其他的结构） data data目录用来存放数据文件，一般是json文件，Hugo提供了相关命令可以从data目录下读取相关的文件数据，然后渲染到HTML页面中，将业务数据与模板分离。（数据文件，很重要但是不用管） layouts 存放自定义的模板文件，Hugo优先使用layouts目录下的模板，未发现再去themes目录下查找。（自定义模板） static 存放静态文件，比如css、js、img等文件目录，Hugo在渲染时，会直接将static目录下的文件直接复制到public目录下，不会做任何渲染。（一些静态文件） themes 存放网站主题，可以下载多个主题，themes目录下的每个子目录代表了一个主题，可以通过在config.toml中通过参数theme指定主题，即theme目录下的子目录名字， 也可以在执行hugo命令渲染时通过增加flag参数–theme=xx指定。（所用主题） assets # 静态文件，比如文章中的图片/视频文件、css等, 将来其下的子目录和文件会在生成时候会自动复制到 public 目录中. （我一般将网站固定的一些图片放在这里，文章的图片和文章放一起） resources # 通过hugo命令一起生成的资源文件，貌似是临时文件**（不用管）** ","date":"2023-04-23","objectID":"/test/:0:0","tags":[],"title":"test","uri":"/test/"},{"categories":["学习笔记"],"content":"有一种巧妙的方法可以在线性时间内，只占用常数空间来实现树的遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。核心思想是利用树的大量空闲指针，实现空间开销的极限缩减（和线索二叉树底层原理相同）","date":"2022-11-08","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/","tags":["算法"],"title":"树的遍历之Morris遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/"},{"categories":["学习笔记"],"content":"有一种巧妙的方法可以在线性时间内，只占用常数空间来实现树的遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。核心思想是利用树的大量空闲指针，实现空间开销的极限缩减（和线索二叉树底层原理相同）。 ","date":"2022-11-08","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/:0:0","tags":["算法"],"title":"树的遍历之Morris遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/"},{"categories":["学习笔记"],"content":"1.熟悉Morris遍历的基本规则 在节点的遍历中，记当前节点为cur（由根节点开始）。 如果cur无左孩子，cur向右移动（cur=cur-\u003eright） 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright 如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur-\u003eleft） 如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur-\u003eright） ​ 实现以上的原则，即实现了morris遍历，而在此过程中的变化的cur结点组成了Morris序。 ​ —–以下图为例，根据遍历规则 cur指向，按照morris原则的第二条第一点，它存在左孩子，cur左子树上最右的节点为5，它的right指针指向空，所以让其指向1，cur向左移动到2。 2有左孩子，且它左子树最右的节点4指向空，按照morris原则的第二条第一点,让4的right指针指向2，cur向左移动到4 4不存在左孩子，按照morris原则的第一条，cur向右移动，在第二步中，4的right指针已经指向了2，所以cur会回到2 重新回到2，有左孩子，它左子树最右的节点为4，但是在第二步中，4的right指针已经指向了2，不为空。所以按照morris原则的第二条第二点，cu’r向右移动到5，同时4的right指针重新指向空 5不存在左孩子，按照morris原则的第一条，cur向右移动，在第一步中，5的right指针已经指向了1，所以cur会回到1 cur回到1，回到头结点，左子树遍历完成，1有左孩子，左子树上最右的节点为5，它的right指针指向1，按照morris原则的第二条第二点，1向右移动到3，同时5的right指针重新指回空 3有左孩子，且它左子树最右的节点6指向空，按照morris原则的第二条第一点,让6的right指针指向3，cur向左移动到6 6不存在左孩子，按照morris原则的第cur一条，cur向右移动，在第七步中，6的right指针已经指向了3，所以cur会回到3 cur重新回到3，有左孩子，它左子树最右的节点为6，但是在第八步中，6的right指针已经指向了3，不为空。所以按照morris原则的第二条第二点，cur向右移动到7，同时6的right指针重新指向空 此时cur无左孩子，cur向右移动，cur为空，遍历结束 ​ Morris序：1-\u003e2-\u003e4-\u003e2-\u003e5-\u003e1-\u003e3-\u003e6-\u003e3-\u003e7 morris遍历 void morris(TreeNode* root) { if(root==nullptr)return ; TreeNode* cur=root; TreeNode* mostRight=nullptr; while(cur!=nullptr) { std::cout\u003c\u003ccur-\u003eval\u003c\u003cstd::endl; mostRight=cur-\u003eleft; if(mostRight!=nullptr) { while(mostRight-\u003eright!=nullptr \u0026\u0026 mostRight-\u003eright!=cur) { mostRight=mostRight-\u003eright; } if(mostRight-\u003eright==nullptr) { mostRight-\u003eright=cur; cur=cur-\u003eleft; continue; }else mostRight-\u003eright=nullptr; } cur=cur-\u003eright; } } ","date":"2022-11-08","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/:0:1","tags":["算法"],"title":"树的遍历之Morris遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/"},{"categories":["学习笔记"],"content":"2. 由Morris序可以发现 没有左子树的结点遍历了一次（4，5，6，7）有左子树的结点遍历了两次（1，2，3） 在有左子树的结点遍历的两次之间，其左子树上的结点均遍历完成。 ps:实质上通过对树的空指针进行利用，此算法通过mostright右孩子的指向来判断是第几次到达节点，指向空为第一次，指向cur为第二次。 在不同时机打印节点可将morris遍历加工为先中后序遍历 ","date":"2022-11-08","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/:0:2","tags":["算法"],"title":"树的遍历之Morris遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/"},{"categories":["学习笔记"],"content":"3. morris遍历加工为先序遍历（即在第一次遍历每个cur结点时打印） 先序 void morrisPre(TreeNode* root) { if(root==nullptr)return ; TreeNode* cur=root; TreeNode* mostRight=nullptr; while(cur!=nullptr) { mostRight=cur-\u003eleft; if(mostRight!=nullptr) { while(mostRight-\u003eright!=nullptr \u0026\u0026 mostRight-\u003eright!=cur) { mostRight=mostRight-\u003eright; } if(mostRight-\u003eright==nullptr) { std::cout\u003c\u003ccur-\u003eval\u003c\u003cstd::endl;//二次型结点的第一次访问 mostRight-\u003eright=cur; cur=cur-\u003eleft; continue; }else mostRight-\u003eright=nullptr; }else{ std::cout\u003c\u003ccur-\u003eval\u003c\u003cstd::endl;//一次型结点的第一次访问 } cur=cur-\u003eright; } } ","date":"2022-11-08","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/:0:3","tags":["算法"],"title":"树的遍历之Morris遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/"},{"categories":["学习笔记"],"content":"4. morris遍历加工为中序遍历（一次型结点访问时打印，二次型结点第二次访问时打印） 中序 void morrisMin(TreeNode* root) { if(root==nullptr)return ; TreeNode* cur=root; TreeNode* mostRight=nullptr; while(cur!=nullptr) { mostRight=cur-\u003eleft; if(mostRight!=nullptr) { while(mostRight-\u003eright!=nullptr \u0026\u0026 mostRight-\u003eright!=cur) { mostRight=mostRight-\u003eright; } if(mostRight-\u003eright==nullptr) { mostRight-\u003eright=cur; cur=cur-\u003eleft; continue; }else{ mostRight-\u003eright=nullptr; std::cout\u003c\u003ccur-\u003eval\u003c\u003cstd::endl;//二次结点的第二次访问 } }else{ std::cout\u003c\u003ccur-\u003eval\u003c\u003cstd::endl;//一次结点的第一次访问 } //或者只在此打印std::cout\u003c\u003ccur-\u003eval\u003c\u003cstd::endl; cur=cur-\u003eright; } } ","date":"2022-11-08","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/:0:4","tags":["算法"],"title":"树的遍历之Morris遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/"},{"categories":["学习笔记"],"content":"5. morris遍历加工为后序遍历（较为复杂，分两阶段） 遍历阶段：寻找二次型结点的第二次访问时刻进行处理，此时逆序打印其左子树右边界(注意左子树右边界不包括根节点) 遍历后阶段：再逆序打印整棵树的右边界（此阶段注意要保证空间复杂度O（1），即不申请额外空间） void morrisPos(TreeNode* root) { if(root==nullptr)return ; TreeNode* cur=root; TreeNode* mostRight=nullptr; while(cur!=nullptr) { mostRight=cur-\u003eleft; if(mostRight!=nullptr) { while(mostRight-\u003eright!=nullptr \u0026\u0026 mostRight-\u003eright!=cur) { mostRight=mostRight-\u003eright; } if(mostRight-\u003eright==nullptr) { mostRight-\u003eright=cur; cur=cur-\u003eleft; continue; }else{ mostRight-\u003eright=nullptr; printEdge(cur-\u003eleft);//二次结点的第二次访问 } } cur=cur-\u003eright; } printEdge(root); } //逆序打印根节点为root的树的右边界() void printEdge(TreeNode* root) { TreeNode* tail=reverseEdge(root); TreeNode* cur=tail; while(cur!=nullptr) { std::cout\u003c\u003ccur-\u003eval\u003c\u003cstd::endl; cur=cur-\u003eright; } reverseEdge(tail); } TreeNode* reverseEdge(TreeNode* root)//将边界看作链表，逆序打印 { TreeNode* pre=nullptr; TreeNode* next=nullptr; while(root!=nullptr) { next=root-\u003eright; root-\u003eright=pre; pre=root; root=next; } return pre; } ","date":"2022-11-08","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/:0:5","tags":["算法"],"title":"树的遍历之Morris遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/"},{"categories":["学习笔记"],"content":"6 .复杂度分析 空间复杂度：O（1）（仅使用了有限的变量，并未开辟其他的内存） 时间复杂度：O（n）（问：在遍历过程中，会寻找左子树右边界，这一过程时间复杂度会超过O（n）吗？答：不会，因为对于所有需要寻找左子树右边界的结点来说他们都会进行两次搜寻过程，全部进行后会发现所有的mostright互不相同，整体代价趋于O（n）故时间复杂度不会超过O（n）） ","date":"2022-11-08","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/:0:6","tags":["算法"],"title":"树的遍历之Morris遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B9%8Bmorris%E9%81%8D%E5%8E%86/"},{"categories":["学习笔记"],"content":"图的遍历：dfs和bfs dfs深度优先遍历：按照某一策略选择一条道路遍历图，当到达无法前进的节点时退回上一节点选择另一条道路，并以此反复递归，直到遍历所有节点。 以树（一种特殊的图）的遍历为例介绍dfs：前序，中序，后序遍历实质均为深度优先遍历 #include \u003cstack\u003e#include \u003cqueue\u003estruct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; //(递归，前序遍历) void dfs(TreeNode* root){ if(root!=nullptr)return ; else{ process(root);//遍历根节点 dfs(root-\u003eleft); dfs(root-\u003eright); } }; //(迭代)使用栈进行维护，将要遍历的节点压栈，然后出栈后检查此节点下是否还有未遍历的节点，有的话压栈，没有的话不断回溯（出栈），根据前序遍历的顺序先压右节点再压左节点 void dfs2(TreeNode* root){ std::stack\u003cTreeNode*\u003e s; s.push(root);//压栈 while(!s.empty()){//每次弹出结点即遍历此节点，遍历完毕，栈为空，结束循环 TreeNode* node=s.top();//纪录节点 s.pop();//弹出节点 process(node);//遍历结点 if (node-\u003eright)s.push(node-\u003eright);//压入右节点 if (node-\u003eleft)s.push(node-\u003eleft);//压入左节点 } } bfs广度优先遍历：指的是从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，遍历完后再依次遍历每个相邻节点的相邻节点。 以树（一种特殊的图）的遍历为例介绍bfs： //使用队列，由根节点开始进入循环，遍历该节点，出队列，判断有无子节点，有则入队列（注意这也保证了下一层遍历顺序） void bfs(TreeNode* root){ std::queue\u003cTreeNode*\u003eq; q.push(root); while (!q.empty()) { TreeNode* front=q.front(); q.pop(); process(front); if(front-\u003eleft) q.push(front-\u003eleft); if(front-\u003eright) q.push(front-\u003eright); } } ","date":"2022-10-26","objectID":"/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86dfs%E5%92%8Cbfs/:0:1","tags":["算法"],"title":"图的遍历：dfs和bfs","uri":"/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86dfs%E5%92%8Cbfs/"},{"categories":["学习笔记"],"content":"c++文件如何工作 源文件(.cpp)-\u003e每一个源文件通过(编译器)生成对应(.obj)-\u003e.obj文件通过（链接器）链接生成(.exe) 编译器怎么工作：编译器将源文件.cpp（文本）变为中继格式.obj 预处理：#include（就是简单地复制粘贴） ​ #define A B(搜索A替换成B) #if … #endif(根据特定条件包含或剔除代码) ( 预处理结束后，c++代码开始被编译成机器码) 每一个.cpp文件在这里称作编译单元（translation unity）（包括include的内容） 编译器优化，包括常数折叠 调用函数时，编译器会生成call以便辅助链接器链接 链接器怎样工作：找到每个符号和函数的位置并把它们连接到一起 一种常见的链接错误：在文件1中定义了函数A，在定义的主体部分调用了B函数，而B在定义在文件2中，文件1中并没有B的声明。这时链接器会由于找不到B而报错，即使在文件1中A没有被调用也会报错（因为链接器不确定以后A是否会被其他文件调用）。此时只需在A前加上static代表这个函数A只针对所在文件定义。 链接的对象必S须明确，函数的参数个数，返回类型都必须明确 链接的对象不能重复，在函数定义时，用static修饰，可以避免#include造成的链接对象重复造成的链接错误，或者用inline修饰，即将函数的主体拿过来取代调用也可以避免（内联函数），或者将所用函数只放在一个翻译单元，其他只inSclude它的声明 函数的声明与定义：声明就像是对编译器的承诺，而定义则是在链接时所必备的函数内容，包含函数的主体部分 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:1:0","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++基础 数据类型，关键字等以及循环，while及for循环的基本用法及结构含义; 条件，if语句基本用法; 控制流，continue，break，return的基本用法等省略。友链：https://blog.csdn.net/Augenstern_QXL/article/details/117249021 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:0","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"头文件 包含各种函数的声明，以便随时调用函数 #pragma once头文件保护符，以防止头文件被多次调用在一个链接文件中 头文件保护符还有另一种，即使用#ifndef…#define…#endif 方括号和圆括号只不过代表引入的头文件是否是绝对路径 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:1","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"指针 计算机和内存打交道，内存即是一切，而指针对于管理和操纵内存极其重要，指针是一个数字，它存储一个内存地址。 指针定义的格式是变量类型后加*，而指针本身也是一个变量，所以我们可以对指针取地址然后赋值给另一个指针（双指针）这样就无限套娃； 用*ptr=10这样的格式可以对指针指向的变量进行操作，但需要注意指针变量声明时设定的指针类型是啥（虽然说实质上就是一个数，但是指定此规则），否则编译器不知道如何将值写入相应内存。 int main() { int a = 10; int* p = \u0026a; int** p2 = \u0026p; std::cout \u003c\u003c *p \u003c\u003c std::endl; std::cout \u003c\u003c p \u003c\u003c std::endl; std::cout \u003c\u003c *p2 \u003c\u003c std::endl; return 0; //结果 //10 //00B6F934 //00B6F934 }; 用new开辟内存到堆上并赋值给指针，要记得结束后delete释放空间，内存后面会详细讲。 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:2","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"引用 引用本质上和指针是一样的(可以看做指针常量)，是基于指针的一种语法糖，来使代码易读易写。 引用是对已存在的变量进行引用，引用本身并不是一个新的变量，不占内存。 引用传参和地址传参都可以改变函数中参变量的值（本质都是地址传参） int main() { int a = 10; int\u0026 ref = a; std::cout \u003c\u003c \u0026ref \u003c\u003c std::endl; std::cout \u003c\u003c \u0026a \u003c\u003c std::endl; return 0; //结果 /*004FF72C 004FF72C*/ } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:3","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"class：面向对象编程（始） 面向对象是一种代码风格，c++，java，c#都是面向对象的语言；而事实上c++支持面向对象，面向过程，基于对象，泛型编程四种。 使用类的结构便利程序员开发 类中变量默认为私有变量 类中的函数叫方法 class Player { public: int x, y; int speed; void Move(int xa, int ya) { x += xa * speed; y += y * speed; } }; int main() { Player player1; player1.x = 5; player1.y = 3; player1.speed = 2; player1.Move(2, 3); std::cout \u003c\u003c player1.x \u003c\u003c std::endl; std::cout \u003c\u003c player1.y \u003c\u003c std::endl; return 0; //结果 /*9 9 10*/ } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:4","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"结构体 结构体和类的区别仅仅是结构体默认变量为公共而类默认变量为私有 区分结构体和类仅仅是靠个人习惯，Cherno的习惯是如果仅仅是表示一些数据就用结构体，如果要创建含有许多内容，许多功能的类，则用类，仅仅是习惯区分而已。 class C1 { int m_A; //默认是私有权限 }; struct C2 { int m_A; //默认是公共权限 }; int main() { C1 c1; c1.m_A = 10; //错误，访问权限是私有 C2 c2; c2.m_A = 10; //正确，访问权限是公共 system(\"pause\"); return 0; } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:5","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"static关键字 在类或者结构体外使用static修饰的符号在link阶段是局部的，也就是它只对它的编译单元可见（即上文所描述的作用）；在编程中，尽量使用static，它可以避免全局变量引起的链接器报错 在类或结构体内的static则表示这部分内存是这个类的所有实例共享的。用static修饰的变量为静态变量，会被所有实例共享，任何一个实例改变它都会改变，所以用实例来调用它并没有意义，可以直接classname::variablename来调用(静态方法也不需要访问实例就可以调用，如classname::functionname())，静态变量在类外定义，类中声明。 class Player { public: int x, y; int speed; static int name; }; static int Player::name=333; int main() { Player player1; Player player2; std::cout \u003c\u003c Player::name \u003c\u003c std::endl; player1.name = 444; std::cout \u003c\u003c Player::name \u003c\u003c std::endl; player2.name = 555; std::cout \u003c\u003c Player::name \u003c\u003c std::endl; return 0; //结果 //333 //444 //555 } 静态方法内部无法访问到非静态变量，因为静态方法没有类实例，这涉及到类的运行机制，类中的每个非静态方法都会获得当前的类实例作为参数（this指针）这是一个隐藏参数，然而静态方法却不具备。静态方法几乎是独立于类中其他成员之外的，可以看做类本身自带的方法，和类外的函数运行机制极其相似(函数本质也是传参，f（x）的定义无法运行而f（int x）却可以，因为指明了参数的类型)。 局部作用域中的静态变量：理解变量生命周期和作用域的概念，特别是生命周期。局部静态变量是指在某一作用域中声明一个变量，这个变量的生命周期是到整个程序结束，变量的作用域只是这个作用域。 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:6","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"枚举 枚举就是一类数的集合，使用枚举就是为了让代码更简洁易懂 枚举的基本结构应掌握（如上，有很多方式，这里不拓展了） 枚举的数据依次递增，第一个默认是0 枚举的类型可以自己设定 普通的枚举并不是一个命名空间，里面的数据只是单纯存在于某个作用域内 enum color:char { BLACK,YELLOW=6,RED }; ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:7","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"构造函数（面向对象编程） 与java和c不同的是，c++必须手动初始化所有的基本类型，否则他们就会被设置成之前存留在内存中的值（如ｊａｖａ中ｉｎｔ和ｆｌｏａｔ有默认初始值为０），而为了不在每次实例化就调用函数去初始化，我们使用构造函数来解决。 构造函数是一个特殊的函数，作用是来初始化类，在每一次实例化类时调用，确保你初始化了所有内存和做了所有你需要的设置，构造函数会在每一次实例化时就自动调用一次（包括new开辟），注意静态函数在被调用时并未初始化，所以不会调用构造函数。 class Entity { public: float X, Y; Entity() { X = 0.0; Y = 0.0; } Entity(float x,float y) { X = x; Y = y; } void Print() { std::cout \u003c\u003c X \u003c\u003c \",\" \u003c\u003c Y \u003c\u003c std::endl; } }; int main() { Entity e; Entity e2(10.0f, 5.0f); e.Print(); e2.Print(); } //0,0 //10,5 特殊情况下，可以按照需求更改或删除构造函数，例如如果你定义了一个只含有静态方法的类，并不希望别人将他实例化。就可以将构造函数写在private权限中，或者将构造函数delete 如：Log()=delete，防止被调用，也就无法实例化。 class Log { private: Log() {};//或者log（）=delete public: static void write() { /*content*/ } }; 构造函数的特点： 名字与类名相同，可以有参数，但是不能有返回值（void也不行） 作用是对对象进行初始化工作，如给成员变量赋值等。 如果定义类时没有写构造函数，系统会生成一个默认的无参构造函数，默认构造函数没有参数，不做任何工作。 如果定义了构造函数，系统不再生成默认的无参构造函数 对象生成时构造函数自动调用，对象一旦生成，不能在其上再次执行构造函数 一个类可以有多个构造函数，为重载关系 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:8","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"析构函数(面向对象编程) 在释放任何内容或者清理内存空间时执行，析构函数是用来释放或销毁构造函数中进行的一些的初始化工作以避免内存泄露。 析构函数使用于栈和堆，因此如果new一个对象（在堆上），则在调用delete时调用析构函数；如果在栈上创建，则在跳出作用域时，对象被删除，调用析构函数。 定义方法和构造函数相比只是1在前面加了~ ~Entity() { std::cout \u003c\u003c \"distory\" \u003c\u003c std::endl; } 可以手动调用析构函数，不过没必要，还有可能造成系统崩溃 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:9","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"继承（面向对象编程） 继承是面向对象编程的三大特性之一，提供了一种方式，将一系列类的所有通用代码放到**父类（基类）**中，避免相似代码的重复编写。 **子类（派生类）**继承父类后，相当于父类的一个超集，继承父类的成员，也可以拓展自己的成员。 派生类拥有基类的全部成员函数和成员变量，不论是private、protected、public。需要注意的是：在派生类的各个成员函数中，不能访问基类的private成员。类的大小是可以变化的，因此会发现子类在继承父类后大小会增加。 class Entity { public: float X, Y; int speed; void Move(int xa, int ya) { X += xa * speed; Y += ya * speed; } }; class Player:public Entity { public: const char* name; void Print() { std::cout \u003c\u003cname\u003c\u003c std::endl; } }; ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:10","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"虚函数（面向对象编程） 在类中声明方法或为函数传参时，调用这个方法的时候，c++总会调用属于这个类型的方法而非它的子类。 class Entity { public: std::string GetName() { return \"entity\"; } }; class Player:public Entity { private: std::string m_Name; public: Player(const std::string\u0026 name) :m_Name(name) {} std::string GetName() { return m_Name; } }; void PrintName(Entity* entity) { std::cout \u003c\u003c entity-\u003eGetName() \u003c\u003c std::endl; } int main() { Entity* e = new Entity(); std::cout \u003c\u003c e-\u003eGetName() \u003c\u003c std::endl; Player* p = new Player(\"mortyda\"); std::cout \u003c\u003c p-\u003eGetName() \u003c\u003c std::endl; PrintName(p);//传入player类型却打印出了“entity” return 0; } //entity //mortyda //entity 如果想要告诉c++我们的传参是它的子类，可以在父类中编写一个方法标记为虚函数，然后在子类中重写这个方法让它去做其他的事情。 class Entity { public: virtual std::string GetName() { return \"entity\"; }//关键字virtual }; class Player:public Entity { private: std::string m_Name; public: Player(const std::string\u0026 name) :m_Name(name) {} override std::string GetName() { return m_Name; }//关键字override省略（最好加上） }; void PrintName(Entity* entity) { std::cout \u003c\u003c entity-\u003eGetName() \u003c\u003c std::endl; } int main() { Entity* e = new Entity(); std::cout \u003c\u003c e-\u003eGetName() \u003c\u003c std::endl; Player* p = new Player(\"mortyda\"); std::cout \u003c\u003c p-\u003eGetName() \u003c\u003c std::endl; PrintName(p);//不管是方法还是函数均正确调用出了子类的方法 return 0; } //entity //mortyda //mortyda 虚函数引入了一种要动态分配的东西，一般通过虚表(vtable)来实现,虚表是存放着所有虚函数的映射的列表 只需在父类的函数中加virtual即可，最好在子类重写时在{}前加override使得代码可读性更好（当然不加也能运行） 虚函数是有成本的，一是需要额外的内存来存储虚表，父类中有一个指针指向虚表，二是在调用虚函数时要遍历虚表来寻找我们想要的函数。 一种特殊的虚函数：纯虚函数 在日常需求中经常会创建一个只包含未实现方法然后交由子类去实际实现功能的类，这样如果想实例化这个类，这个函数必须在在子类中实现（只有实现了所有纯虚函数的类才可以被实例化）。这个父类通常被称为接口，只需将虚函数的body部分改为=0即可 class Entity { public: virtual std::string GetName() = 0; }; ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:11","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中的可见性（面向对象编程） 可见性是面向对象中的概念，指的是一个类中的成员或方法是否可见，谁能够访问，调用，使用它。c++中有三个访问修饰符public，private，protected public所有人可见；protect仅自己和子类可见；private尽自己可见，但有个东西叫**友元（friend）**可以将其他类或函数标记为当前类的友元以允许其访问这个类的私有成员。 可见性是非常有意义的，可见性为他人提供了建议和指导。 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:12","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"数组 数组的数据是连续的 一个数组就是一个指针(new)，指向一段连续的内存空间，访问数组不同索引时，指针偏移相应数据类型对应字节x索引数 #include \u003ciostream\u003eint main() { int example[5]; for (int i = 0; i \u003c 5; i++) { example[i] = i; } int* ptr = example; std::cout \u003c\u003c example[0] \u003c\u003c std::endl; //0 std::cout \u003c\u003c ptr \u003c\u003c std::endl; std::cout \u003c\u003c example \u003c\u003c std::endl; //00CFFA08 //00CFFA08 //数组是一个指针 std::cout \u003c\u003c *(ptr+1) \u003c\u003c std::endl; std::cout \u003c\u003c *((int*)((char*)ptr+4)) \u003c\u003c std::endl; //1 //1 //指针偏移相应数据类型对应字节x索引数 std::cout \u003c\u003c (ptr+1) \u003c\u003c std::endl; //00CFFA0C return 0; } 一般用new来动态分配内存来创建数组，这是由于用new分配的内存生命周期长，会一直存在直到你手动删除它,因此如果你有一个函数要返回函数内新创建的数组，就应该用new来分配;另一种是在栈上直接创建数组，最好不要这样用 #include \u003ciostream\u003eint main() { int example[5];//栈上创建，跳出作用域时被销毁 int* another = new int[5];//堆上创建，一直存在 delete[] another; return 0; } 内存间接寻址：栈上创建数组，会有指针直接指向它的内存；堆上创建数组，则会指向存放它地址的指针，导致访问时在内存中跳来跳去，影响性能； class Entity { public: int example[5]; //栈数组 Entity() //创建一个构造函数，用来初始化所有值为2 { for (int i = 0; i\u003c 5;i++) example[i] = 2; } }; int main() { Entity e; //实例化一个对象。如果我们查看Entity e的内存地址，可以看到Entity的内存上实际就是一行，包含了数组中所有的2，所有的数据都在这儿 std::cin.get(); } c++11的标准库中定义的有std：：array，有很多优于原生数组的点，如边界检查，记录数组大小等。 原生数组的大小是无法访问的（当然也有一些方法，不可靠，而且在栈上创建的话，如果数组作为函数参数，就无法使用sizeof来计算）。 int a[5]; //栈数组 sizeof(a); //20bytes int count = sizeof(a) / sizeof(int); //5 int* example = new int[5]; //堆数组 int count = sizeof(example) / sizeof(int); //1 数组的大小必须好好维护，在栈中为数组申请内存时，大小必须是在编译时要知道的常量（此处挖坑） ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:13","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"字符串 c++中有数据类型char是字符型，将指针转化为字符型指针，就可以根据字节进行运算，也可以帮助我们分配内存缓冲区（1k内存就分配1024字节）。因为有不同语言存在，一个字符一般不止有一个字节（8位，有2**8=256种组合，不满足所有语言的需要）所以使用utf-16. 字符串其实就是一组字符数组，在内存中就是一串连续的内存空间，空间末尾会有一个字符串的休止符标记为0，这样指针在跑的时候就知道字符串在哪里结束。 一般用const char* zfc=“sasd”声明一个字符数组（c风格）这里的const默认加上，表明字符串大小不可变（因为实际上就是一块已声明的内存），而且在c++中用双引号定义字符串时，默认它就是一个const char数组而非char数组，当然需要操作的时候可以手动改成char。 const char* name = \"cherno\"; //c风格字符串 char* name = \"cherno\" //报错，因为C++中默认的双引号就是一个字符数组const char* char name2[8] = { 'm','o','r','t','y','d','a'};;//报错，缺少空终止符 char name2[8] = { 'm','o','r','t','y','d','a', 0};//正确 char name2[8] = { 'm','o','r','t','y','d','a', '\\0'};//正确,因为ascii码'\\0'就是null 然而在c++标准库中存在string__basic模板类，以及用char作为参数带入模板类产生的string类可以使用，在使用时要引入string头文件，string中含有接受参数char指针及const char指针的构造函数（虽然在iostream中含string的定义但无法输出流，而string对输出流做了重载） string中含有很多重载函数，因此可以支持许多操作，包括字符串相加，字符串大小啥的 #include \u003ciostream\u003e#include \u003cstring\u003eint main() { const char* name = \"mortyda\";//c 风格 std::string name2 = \"mortyda\";//c++风格 std::cout \u003c\u003c name2 \u003c\u003c std::endl; return 0; } 字符串字面量(string literal) 字符串字面量就是双引号之间的一串字符，默认情况下是一个const char数组。 Char *p =”hello“//p是一个指针，直接指向常量区，修改p[0]即是修改常量区的内容，是不允许的。 Char p[] =”hello“//编译器在栈上创建一个字符串p，把“hello”从常量区复制到p，修改p[0]就相当于修改数组元素一样，是允许的。 #include \u003ciostream\u003e#include \u003cstring\u003eint main() { char name[] = \"mortyda\"; std::cout \u003c\u003c name \u003c\u003c std::endl; return 0; } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:14","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"const关键词 const更像一个假的关键字，因为它在生成代码时并没有做什么，const是一种针对开发人员写代码的强制规则，是一种让代码保持整洁的机制，const让某个东西保持不变。 变量前加const可以变成常量,通过强制转换可以绕过const的约束（不推荐）; const int Age =90; int* a = new int; *a = 2; a = \u0026Age //error! a =(int*)\u0026Age //ok 指针前加const变为常量指针，指针指向可改，指向的值不可改 指针后加const变为指针常量，指针指向不可改，指向的值可改 指针前后都加const那就是都不可更改 const int* a = new int; *a = 2; //error! 不能再去修改指针指向的内容了。 a =(int*)\u0026Age //可以改变指针指向的地址 int* const a = new int; *a = 2; //ok a =(int*)\u0026Age //error 在类中，在方法名（） 后加const表明这个方法不可修改类中的任何内容，而在这里又有mutable关键词，允许const方法修改用mutable修饰的变量。 class Entity { private: int m_x,m_y; public: int Getx() const //const的第三种用法，他和变量没有关系，而是用在方法名的后面 { return m_x; //不能修改类的成员变量 m_x = 2; //ERROR! } void Setx(int a) { m_x = a; //ok } }; void PrintEntity(const Entity\u0026 e) //const Entity调用const函数 { std::cout \u003c\u003c e.Getx() \u003c\u003c std::endl; } int main() { Entity e; } mutable还有一种情况是在lambda表达式中使用，它可以创建局部变量进行操作（视频里只演示了这一个功能，绝大多数情况下mutable只是在类中使用） #include \u003ciostream\u003eint main() { int x = 8; auto f = [=]() mutable { x++; std::cout \u003c\u003c x \u003c\u003c std::endl; }; f(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:15","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"构造函数初始化列表 在c++的构造函数中应该进行成员初始化，就是在构造函数的函数名后加：achengyuan（0）这样来进行初始化，注意如果有多个成员变量，初始化的时候必须按照声明变量的顺序进行 class Entity { private: std::string m_Name; int score; public: Entity() : m_Name(\"unknown\"),score(0) { } }; 构造函数初始化列表很重要，可以把它看做一种代码风格，但跟应该记住它有重要的功能，在创建实例时，如果没有初始化列表，就可能会同时创建两个变量而造成性能浪费 ;其中一个直接浪费掉了 #include \u003ciostream\u003e#include \u003cstring\u003e class Example { public: Example() { std::cout \u003c\u003c \"create\" \u003c\u003c std::endl; } Example(int x) { std::cout \u003c\u003c \"create with\" \u003c\u003c x \u003c\u003c std::endl; } }; class Entity1 { private: std::string m_Name; Example example;//此时也会创建实例 public: Entity1() { m_Name = std::string(\"unknown\"); example = Example(12);//又创建了一遍 } }; int main() { Entity1 e; return 0; } //create //create with12 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:16","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"三元运算符 读懂： 例：s_speed=s_level\u003e5?10:15 嵌套时：s_speed=s_level\u003e5?s_level\u003e10? 15:10:5 三元运算符时运算速度快一些，代码简洁一些（不用创建多余的变量） 尽量不对三元运算符进行嵌套 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:17","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"如何创建对象 创建对象需要分配内存，在c++中我们可以选择在堆或栈上创建对象 首选用栈，最快最简洁，如果使用堆就要用new关键词，int* sth=new int(100) 栈上创建的生命周期会受到作用域的限制，而且栈空间一般十分有限，chenro讲的跟网上的大差不差 C++创建对象的两种方式 - 邱明成 - 博客园 (cnblogs.com) ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:18","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"new关键词 基本用法不说了（int*b=new int[50]）,在堆上分配内存并返回相应指针,如果用new和[]开辟内存，delete时也要加[],否则不用。 int* ptr = new int;//找到连续四字节的内存并返回它的地址 int* ptr2 = new int[3];//创建数组对象，占用12字节 Entity1* ptr3=new Entity1()//创建自定义类对象，括号可以省去，因为有默认构造函数 delete ptr; delete[] ptr2; delete ptr1; 和类一起使用时（Classa *a=new Classa()，不加括号则调用默认构造函数）不仅分配了内存，而且调用了构造函数 new 关键字创建对象时 对于内置类型：加括号会初始化，不加括号不初始化；对于自定义类型，都会调用默认构造函数，加不加括号没区别。 一般情况下new关键词会调用底层c函数：malloc（是用来分配内存的，传入一个需要的size返回void指针指向内存地址） Entity1* ptr3 = new Entity1();//创建自定义类对象，括号可以省去，因为有默认构造函数 Entity1* ptr4 =(Entity1*) malloc(sizeof(Entity1));//malloc函数返回void型指针，需强转，且此时未调用构造函数 其实new支持一个placement new语法，可以决定内存来自哪里（此时并未开辟内存，而是在指定内存上调用构造函数进行了初始化） Entity1* ptr3 = new Entity1(); Entity1* ptr5 = new(ptr3) Entity1(); delete ptr5; new是一个操作符，也是可以重载的。 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:19","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"隐式转换及explicit关键字 隐式转换就是自动的将一种数据类型作为另一种类型使用。比如类中的构造函数如果初始化了某个属性int sth，那么就可以在声明变量时直接传参classa a=8；（举例） c++只支持一次的隐式转换。在构造函数前加explicit关键词，可以禁止该类对象隐式转换 class Entity2 { private: std::string m_Name; int m_Age; public: Entity2(const std::string\u0026 name) :m_Name(name),m_Age(-1){} Entity2(int age)//explicit Entity2(int age) 则b=20会报错 :m_Name(\"UnKnown\"), m_Age(age) {}; }; int main() { //Entity2 a = Entity2(\"Mortyda\"); //Entity2 b = Entity2(20); Entity2 a = (std::string)\"mortyda\";//手动进行了一次转换，因为c++只支持一次隐式转换，但是charno直接将字面量赋给了a却没报错，不知道为啥 Entity2 b = 20;//隐式转换 return 0; } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:20","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中的运算符以及运算符重载 在你的程序中定义运算符，重载是指给他一个新的含义或者是增加函数或者是重新创建 除了在值得的时候对运算符符进行重载否则尽量少用 重载的方式和定义函数差不多，返回类型 operator 运算符 (参数)（粗略形容一下）*补：后面的应用中发现了可以重载为友元函数。 struct Vector2 { float x, y; Vector2(float x, float y) : x(x),y(y){} Vector2 Add(const Vector2\u0026 other)const { return Vector2(x + other.x, y + other.y); } Vector2 operator+(const Vector2 \u0026 other) const//对+进行重载，当然根据不同代码风格也可以在add函数中反过来调用operator+ { return Add(other); } }; int main() { Vector2 a(1.1f, 1.2f); Vector2 b(1.3f, 1.4f); std::cout \u003c\u003c a.Add(b).x\u003c\u003c a.Add(b).y \u003c\u003c std::endl; std::cout \u003c\u003c (a+b).x \u003c\u003c (a+b).y \u003c\u003c std::endl; return 0; } //2.42.6 //2.42.6 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:21","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中的this指针 this指针指向当前对象实例,在类中调用类外函数时可以使用this传参 class Entity; //前置声明。 void PrintEntity(Entity* e); //在这里声明 class Entity { public: int x,y; Entity(int x, inty) { this-\u003ex = x; this-\u003ey = y; PrintEntity(this); //我们希望能在这个类里调用PrintEntity,就可以传入this } }; void PrintEntity(Entity* e) //在这里定义 { //print something } this可以避免类中方法定义时形参和类中其他成员重名 class Entity { public: int x,y; Entity(int x, int y) { this-\u003ex = x;//等同(*this).x this-\u003ey = y; } }; 在有const修饰的类的方法中，this一个常量指针，指向的值不可以改 int GetX() const //在函数后面加上const是很常见的，因为他不会修改这个类 { ` Entity* e = this;//ERROR! const Entity* e= this;//ok,表明此时this类型为const Entity* } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:22","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"对象的生存周期（基于栈的生存周期） 在c++中每当进入一个作用域中时，我们就是在push一次栈，push的内容就是声明的变量，而当作用域结束时，变量的生命就结束了。 #include \u003ciostream\u003e#include \u003cstring\u003e class Example { public: Example() { std::cout \u003c\u003c \"create\" \u003c\u003c std::endl; } Example(int x) { std::cout \u003c\u003c \"create with\" \u003c\u003c x \u003c\u003c std::endl; } ~Example() { std::cout \u003c\u003c \"die\"\u003c\u003c std::endl; } }; int main() { { Example* exa=new Example(); //create Example* exa2; //create //die } } 由于不知道栈上创建变量的生存周期很短，编译可能会产生错误，因为离开了局部作用域后，变量就销毁了。 //经典错误，栈上创建数组 int CreateArray() { int array[50]; //在栈上创建的 return array; } int main() { int* a = CreateArray(); //不能正常工作 } 在栈上创建变量是有意义的，可以帮助我们自动化代码。一个简单的例子是作用域指针，本质上是一个类，是一个指针的包装器，构造时在堆上分配指针，在析构时删除指针，我们可以自动化new和delete。作用域指针的例子大致就是在一个类的构造函数和析构函数创建和删除指针（在堆上）然后通过栈上创建类对象达到堆上创建指针又能自动化删除的功能。 #include \u003ciostream\u003e#include \u003cstring\u003e class Example { public: Example() { std::cout \u003c\u003c \"create\" \u003c\u003c std::endl; } Example(int x) { std::cout \u003c\u003c \"create with\" \u003c\u003c x \u003c\u003c std::endl; } ~Example() { std::cout \u003c\u003c \"die\"\u003c\u003c std::endl; } }; class ScopedPtr { private: Example* m_Ptr; public: ScopedPtr(Example* ptr) :m_Ptr(ptr) { } ~ScopedPtr() { delete m_Ptr; } }; int main() { { Example* e2 = new Example(); ScopedPtr e = new Example(); } return 0; } //create //create //die ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:23","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中的智能指针 智能指针本质上是原始指针的一种包装，将new和delete自动化 unique_ptr，是作用域指针（上一节的案例即为一种作用域指针），unique_ptr无法被复制，一旦复制会指向同一块内存，同生则生，同死则死。 在include头文件后 使用std：：unique_ptrentity=std::make_unique();优于unique_ptr entity（new entity（）），这可以避免异常（不会由于得到一个没有用的悬空指针而造成内存泄漏） 不可以std::unique_ptr entity=new Entity();创建，因为unique_ptr构造函数是explicit的无法使用隐式转换。 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cmemory\u003e class Example { public: Example() { std::cout \u003c\u003c \"create\" \u003c\u003c std::endl; } Example(int x) { std::cout \u003c\u003c \"create with\" \u003c\u003c x \u003c\u003c std::endl; } void Print() {}; ~Example() { std::cout \u003c\u003c \"die\"\u003c\u003c std::endl; } }; int main() { { std::unique_ptr\u003cExample\u003e example(new Example());//right std::unique_ptr\u003cExample\u003e example2=std::make_unique\u003cExample\u003e();//better //std::unique_ptr\u003cExample\u003e example=new Example()//wrong example-\u003ePrint(); } return 0; } //create //create //die //die shared_ptr,使用引用计数（引用计数是一种介意跟踪你的指针有多少引用的方法，一旦引用到0，指针就被删除） 创建时使用std::shared_ptrsharedEntity = std::make_shared();更好，它的原因不同于unique_ptr，而是因为shared_ptr需要分配另一块内存存储引用计数，如果使用new关键词再用构造函数的话会进行两次分配(多了一次new Entity的分配)，效率不高，儿make_share则可以将它们合并到一次。 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cmemory\u003e class Example { public: Example() { std::cout \u003c\u003c \"create\" \u003c\u003c std::endl; } Example(int x) { std::cout \u003c\u003c \"create with\" \u003c\u003c x \u003c\u003c std::endl; } void Print() {}; ~Example() { std::cout \u003c\u003c \"die\"\u003c\u003c std::endl; } }; int main() { { std::shared_ptr\u003cExample\u003esharedExample2;//持有sharedExample的引用，实例不会被销毁 { std::shared_ptr\u003cExample\u003e sharedExample = std::make_shared\u003cExample\u003e(); sharedExample2 = sharedExample; } std::cout \u003c\u003c \"still alive\" \u003c\u003c std::endl; } return 0; } //create //still alive //die 通常伴随shared_ptr一起使用的还有weak_ptr,声明方式同上，可以给它赋值为shared_ptr而不会增加引用 { std::weak_ptr\u003cEntity\u003e e0; { std::shared_ptr\u003cEntity\u003e sharedEntity = std::make_shared\u003cEntity\u003e(); e0 = sharedEntity; } //此时，此析构被调用，内存被释放 } 智能指针是值得讨论的话题，但目前来说无法替代new和delete，在需要的时候应该尽量使用unique_ptr,因为开销很少，当需要在对象之间共享时，应该使用shared_ptr ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:24","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中的复制与拷贝构造函数 拷贝是指将一个对象或者语句或一段数据从一个地方复制到另一个地方。有时候我们并不想重新复制一遍，而是在原来的数据上进行修改。 在使用赋值运算符时，复制是一直都会执行的，有时候是具体的内容，有时是内存的地址（引用除外，引用只是起了个别名） （cherno在视频中带我们用原始的方式定义了字符串类，然而在拷贝时却发生了错误，这是因为进行了浅拷贝，在字符串类的定义中存在指针的构造，而浅拷贝只会复制指针的地址而非创造新的指针，因此在调用析构函数时，指针指向的内存会释放两遍，产生了报错，所以我们需要深拷贝） #include \u003ciostream\u003e#include \u003cstring\u003eclass String { private: char* m_Buffer; unsigned int m_Size; public: String(const char* string) { m_Size = strlen(string); m_Buffer = new char[m_Size + 1]; for (int i = 0; i \u003c m_Size+1; i++) { m_Buffer[i] = string[i]; } //memcpy(m_Buffer,string,m_Size+1); } String(const String\u0026 other)//此为自定义拷贝构造函数，而默认构造函数仅仅复制了成员变量地址 :m_Size(other.m_Size) { m_Buffer = new char[m_Size+1]; memcpy(m_Buffer, other.m_Buffer, m_Size+1); std::cout \u003c\u003c \"copy\" \u003c\u003c std::endl; } ~String() { delete[] m_Buffer; std::cout \u003c\u003c \"die\"\u003c\u003c std::endl; } char\u0026 operator[](unsigned int index) { return m_Buffer[index]; } friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string);//重载\u003c\u003c为友元，便于直接使用m_Buffer }; std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string) { stream \u003c\u003c string.m_Buffer; return stream; } void PrintString(const String\u0026 string)//const引用传参，防止字符串被修改，且避免多余复制进行 { std::cout \u003c\u003c string \u003c\u003c std::endl; } int main() { String string = \"mortyda\"; String string2 = string; string2[4] = 'i'; //std::cout \u003c\u003c string \u003c\u003c std::endl; //std::cout \u003c\u003c string2 \u003c\u003c std::endl; PrintString(string); PrintString(string2); std::cin.get(); } 深拷贝：深拷贝是复制整个对象。这里使用的方法是拷贝构造函数。 拷贝构造函数：一种构造函数，当你复制第二个字符串时它会被调用。c++中有默认提供的拷贝构造函数。 c++默认会有一个拷贝构造函数，它所做的就是复制内存，将被复制的对象的内存浅拷贝进目标。如果想进行深拷贝则需要在拷贝构造函数中重新创建空间，分配内存并进行拷贝。（在cherno演示中还写了一个print函数用于输出字符串，此时传入的参数应该是字符串的引用，避免了再一次的复制，此外，在参数前用const修饰避免了参数的改变） ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:25","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中的箭头操作符 就是（*ptr）.func（）的快捷方式即ptr-\u003efunc()即指针用箭头访问对象的方法或变量 cherno对-\u003e进行了运算符重载，代码更加简洁。 #include \u003ciostream\u003eclass Entity { private: int x; public: void Print() const //添加const { std::cout \u003c\u003c \"hello!\" \u003c\u003c std::endl; } }; class ScopedPtr { private: Entity* m_Ptr; public: ScopedPtr(Entity* ptr) : m_Ptr(ptr) { } ~ScopedPtr() { delete m_Ptr; } Entity* operator-\u003e() { return m_Ptr; } const Entity* operator-\u003e() const //添加const { return m_Ptr; } }; int main() { { const ScopedPtr entity = new Entity(); //如果是const，则上面代码要改为const版本的。 entity-\u003ePrint(); } std::cin.get(); return 0; } 使用箭头操作符可以获取内存中某个成员变量的偏移量（这一部分受教很多，指针-\u003e属性这一方法访问属性实际上是将指针和属性的值相加得到属性地址进行访问，所以使用空指针即在0基础上进行偏移，而通过对象访问实质上也是地址的访问；而cherno在演示–\u003e的第一种用法时只是说相当于对指针解引用然后再调用函数，我找不到点操作符的机制，所以暂且认为箭头操作符只是效果上跟解引用一样，实质上是通过偏移量相加进行访问的吧） struct vec2 { int x,y; float pos,v; }; int main() { int offset = (int)\u0026((vec2*)nullptr)-\u003ex; // x,y,pos,v的offset分别为0,4,8,12 std::cout\u003c\u003coffset\u003c\u003cstd::endl; std::cin.get(); return 0; } 引自B站评论： 因为\"指针-\u003e属性\"访问属性的方法实际上是通过把指针的值和属性的偏移量相加，得到属性的内存地址进而实现访问。 而把指针设为nullptr(0)，然后-\u003e属性就等于0+属性偏移量。编译器能知道你指定属性的偏移量是因为你把nullptr转换为类指针，而这个类的结构你已经写出来了(float x,y,z)，float4字节，所以它在编译的时候就知道偏移量(0,4,8)，所以无关对象是否创建 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:26","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中的动态数组Vector STL库本质上是一个装满容器，容器类型的库，这些容器包含特定的数据。STL库可以模板化任何东西，因此被称为标准模板库，容器包含的底层数据类型都可以由我们自己决定，所有内容都由模板组成。 一般的动态数组经常是固定长度，无法进行拓展。而Vector则可以进行动态拓展 vector数组在一开始可以不指定它的长度。在分配长度后，如果超过了分配的大小，系统会在内存中重新创建一个比第一个更大的新数组，将所有元素都复制到这里并删除旧的那一个 这里讨论了栈分配和堆分配，cherno建议视情况而定，并推荐尽量栈分配，指针应是最后的选择。在技术上，储存vertex对象比储存地址更好，因为是连续的紧挨着的一串内存，在操作时位于一条缓存线上（以后会讲）。唯一问题是在调整vector大小时可能比较缓慢。 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cvector\u003e struct Vertex { float x, y, z; }; std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const Vertex\u0026 vertex) { stream \u003c\u003c vertex.x \u003c\u003c \",\" \u003c\u003c vertex.y \u003c\u003c \",\" \u003c\u003c vertex.z; return stream; } int main() { //Vertex* vertices = new Vertex[5]; std::vector\u003cVertex\u003e vertices;//创建，与java不同的是，此处可以传递int等原始类型 vertices.push_back({ 1,2,3 });//添加 vertices.push_back({ 4,5,6 }); for (Vertex\u0026 v : vertices) { std::cout \u003c\u003c v \u003c\u003c std::endl; } vertices.erase(vertices.begin() + 1);//删除，传参为迭代器 for (Vertex\u0026 v : vertices) { std::cout \u003c\u003c v \u003c\u003c std::endl; } std::cin.get(); return 0; } 参数传递时，如果不对数组进行修改，请使用引用类型传参。 void Function(const std::vector\u003cT\u003e\u0026 vec){}; vector的使用优化。了解所在环境以及工作原理和可用工具，是进行优化的关键。比如如下代码： std::vector\u003cVertex\u003e vertices; vertices.push_back(Vertex(1,2,3)); vertices.push_back(Vertex(4,5,6)); vertices.push_back(Vertex(7,8,9)); 这里实质上Vertex的拷贝构造函数复制了6次，有两点不足，一是vector的长度没有初始化，导致每一次增加就会进行一次扩容，在此之前加vertices.reserve(3);可以指定需要的内存（而非创建3个对象）来解决。二是每一次对象都是先在main函数的栈上创建，然后再放到数组中去，导致复制了三次。应将push_back（）替换为emplace_back（）,使得在实际vector内存中使用以下参数来创建一个对象。 vertices.reserve(3); vertices.emplace_back(1, 2, 3); vertices.emplace_back(4, 5, 6); vertices.emplace_back(7, 8, 9); ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:27","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中使用库（静态链接） c++使用库两种方式，一是保留库的副本获取实际依赖库的源代码并自己进行编译（一般大型项目）；二是以二进制文件的形式进行链接（小项目，更快更容易）。这里先介绍第二种，以glfw库为例。 库一般包含着两部分，includes（包含目录）和library（库目录），includes目录是一堆头文件，library目录包含预先构建的二进制文件（对于glfw库来说，其中包含动态库和静态库） 动态库与静态库区别（这里仅仅是简述）：静态链接表明此库会被放到可执行文件中（.exe）动态链接则是在程序运行时被链接的，此时装载动态链接库。技术上静态链接要更快，因为编译器或链接器连接时会优化。 dll是一种运行时动态链接库，lib为静态链接库，而下图中的dll.lib文件实质上是一个静态库，存储动态库的所有函数，符号的位置，以便在编译时链接他们，否则需要用函数名来链接。 在include时用\u003c\u003e还是“”（实际上没有区别）cherno习惯当外部依赖库时用\u003c\u003e,当内部使用，和解决方案一起编译时则用“” ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:28","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中处理多返回值 方法一（最好）：若有个函数叫ParseShader需要返回两个字符串。可以选择的解决方法是：创建一个叫做ShadweProgramSource的结构体，它只包含这两个字符串。若还想返回一个整数或其他不同类型的东西，可以把它添加到结构体中并返回它。 //cherno的例子 struct ShaderProgramSource { std::string VertexSource; std::string FragmentSource; int a; } static ShaderProgramSource ParseShader(const std::string\u0026 filepath) { } return {vs,fs}; 方法二：把函数定义成void，然后通过参数引用传递的形式“返回”两个字符串，这个实际上是修改了目标值，而不是返回值，但某种意义上它确实是返回了两个字符串，而且没有复制操作，技术上可以说是很好的。但这样做会使得函数的形参太多了，可读性降低，有利有弊 。（也可以使用指针传递，指针传递有一个好处就是可以传入null值的指针） #include \u003ciostream\u003evoid GetUserAge(const std::string\u0026 user_name,bool\u0026 work_status,int\u0026 age) { if (user_name.compare(\"cherno\") == 0) { work_status = true; age = 18; } else { work_status = false; age = -1; } } int main() { bool work_status = false; int age = -1; GetUserAge(\"cherno\", work_status, age); std::cout \u003c\u003c \"查询结果：\" \u003c\u003c work_status \u003c\u003c \" \" \u003c\u003c \"年龄：\" \u003c\u003c age \u003c\u003c std::endl; getchar(); return 0; } 方法三：将array（数组）或vector作为函数的返回值 //设置是array的类型是stirng，大小是2 std::array\u003cstd::string, 2\u003e ChangeString() { std::string a = \"1\"; std::string b = \"2\"; std::array\u003cstd::string, 2\u003e result; result[0] = a; result[1] = b; return result; //若返回两种以上则可以使用vector。它和array的区别是array在栈上创建，而vector会把它的底层存储在堆上，所以std::array会更快。 } 方法四：使用std::pair返回两个返回值 可以返回两个不同类型的数据。 使用std::pair这种抽象数据结构，该数据结构可以绑定两个异构成员。这种方式的弊端是只能返回两个值。 #include \u003ciostream\u003e std::pair\u003cbool, int\u003e GetUserAge(const std::string\u0026 user_name) { std::pair\u003cbool, int\u003e result; if (user_name.compare(\"xiaoli\") == 0) { result = std::make_pair(true, 18); } else { result = std::make_pair(false, -1); } return result; } int main() { std::pair\u003cbool, int\u003e result = GetUserAge(\"xiaolili\"); std::cout \u003c\u003c \"查询结果：\" \u003c\u003c result.first \u003c\u003c \" \" \u003c\u003c \"年龄：\" \u003c\u003c result.second \u003c\u003c std::endl; getchar(); return 0; } 方法五：使用std::tuple返回三个或者三个以上返回值 std::tuple这种抽象数据结构可以将三个或者三个以上的异构成员绑定在一起，返回std::tuple作为函数返回值理论上可以返回三个或者三个以上的返回值。 tuple相当于一个类，它可以包含多个变量，但他不关心类型，用tuple需要包含头文件 #include \u003ciostream\u003e#include \u003ctuple\u003e std::tuple\u003cbool, int,int\u003e GetUserAge(const std::string\u0026 user_name) { std::tuple\u003cbool, int,int\u003e result; if (user_name.compare(\"xiaoli\") == 0) { result = std::make_tuple(true, 18,0); } else { result = std::make_tuple(false, -1,-1); } return result; } int main() { std::tuple\u003cbool, int,int\u003e result = GetUserAge(\"xiaolili\"); bool work_status; int age; int user_id; std::tie(work_status, age, user_id) = result; std::cout \u003c\u003c \"查询结果：\" \u003c\u003c work_status \u003c\u003c \" \" \u003c\u003c \"年龄：\" \u003c\u003c age \u003c\u003c\" \"\u003c\u003c\"用户id:\"\u003c\u003cuser_id \u003c\u003cstd::endl; getchar(); return 0; } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:29","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中的模板 模板允许你定义一个可以根据你的用途进行编译的模板（有意义下）。故所谓模板，就是让编译器基于DIY的规则去为你写代码 。 模板在调用函数时才开始根据所给的参数进行函数创建 #include \u003ciostream\u003e template\u003ctypename T\u003e void Print(T value) { std::cout \u003c\u003c value \u003c\u003c std::endl; } int main() { shiyongdechangji Print(3); Print(\"sasa\"); return 0; } 模板的使用范围很广，下面是在类中使用的场景（模版功能强大，但不应该滥用） #include \u003ciostream\u003etemplate\u003cint N\u003e class Array { private: int m_Array[N]; public: int GerSize(){return N;} }; int main() { Array\u003c3\u003e exa; std::cout \u003c\u003c exa.GerSize() \u003c\u003c std::endl; return 0; } //再进一步： #include \u003ciostream\u003e template\u003ctypename T,int N\u003e class Array { private: T m_Array[N]; public: int GerSize(){return N;} }; int main() { Array\u003cstd::string,3\u003e exa; std::cout \u003c\u003c exa.GerSize() \u003c\u003c std::endl; return 0; } ###　c++中的堆与栈内存比较 堆与栈存在于内存之中，物理位置都一样，栈通常是一个预定义大小的内存区域，通常约为2兆字节左右。堆也是一个预定义了默认值的区域，但是它可以随着应用程序的进行而改变。 是否使用new关键字决定了堆分配与栈分配 栈分配方式： 在栈上，分配的内存都是连续的。添加一个int，则栈指针（栈顶部的指针）就移动4个字节，所以连续分配的数据在内存上都是连续的。栈分配数据是直接把数据堆在一起（所做的就是移动栈指针），所以栈分配数据会很快 。 如果离开作用域，在栈中分配的所有内存都会弹出，内存被释放。 堆分配方式： 在堆上，分配的内存都是不连续的，new实际上做的是调用malloc函数，在内存块的空闲列表中找到空闲的内存块，然后把它用一个指针圈起来，然后返回这个指针。（但如果空闲列表找不到合适的内存块，则会询问操作系统索要更多内存，而这种操作是很麻烦的，潜在成本是巨大的） 离开作用域后，堆中的内存仍然存在 尽量使用栈分配，效率高开销少。 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:30","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中的宏 宏是在预处理阶段评估，比模板早一点，用于将代码中的文本替换为其他东西（纯文本替换）（不一定是简单的替换，调用宏的方式可以自定义） #include \u003ciostream\u003e#defind WAIT std::cin.get() //简单替换 #define log(x) std::cout\u003c\u003cx\u003c\u003cstd::endl//带参数的替换 int main() { log(\"assad\"); WAIT; } 宏可以帮助调试,根据编译器模式为debug还是release预定义不同的变量，在项目属性-C/C++-预处理器-预处理器定义，里面为debug和release分别添加不同的变量 PR_REBUG 和 PR_RELEASE，那么在项目选择不同编译模式的时候，就会分别预定义这两个变量，以此来控制不同版本的代码状况。 #ifdef PR_DEBUG #define LOG(x) std::cout\u003c\u003cx\u003c\u003cstd::endl; #else #define LOG(x) #endif int main() { LOG(\"ydc\"); std::cin.get(); } 或者使用if语句代替ifdef判断，一般更好一些。只需设置Debug(PR_DEBUG == 1) 使用if 0相当于false，无视包含的宏 #include \u003ciostream\u003e #if 0//从这里到最后的endif的宏都被无视掉了，某种意义上的删除 #if PR_DEBUG == 1 #defind LOG(x) std::cout \u003c\u003c x \u003c\u003c std::endl #elif defind(PR_RELEASE) #endif #endif //结束 int main() { LOG(\"hello\"); return 0; } 宏定义可以不写在同一行，代码较多时用反斜杠换行 #define MAIN int main()\\ {\\ std::cin.get;\\ } MAIN ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:31","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"auto关键字 auto关键字可以自动推断出变量的类型，并且根据类型的改变而自动调整。使用auto在api改变时不需要改变相关系的代码，但也可能会造成依赖变量类型的代码出现错误，因此这种情况下不用 在使用长类型比如迭代器或者长类型名时用auto很方便。 //迭代器 int main() { std::vector\u003cstd::string\u003e strings; strings.push_back(\"apple\"); strings.push_back(\"orange\"); //it 类型为std::vector\u003cstd::string\u003e::iterator for (auto it = strings.begin(); it != strings.end(); it++) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } } //长类型名 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cvector\u003e#include \u003cunordered_map\u003e class Device{}; class DeviceManager { private: std::unordered_map\u003cstd::string, std::vector\u003cDevice *\u003e\u003e m_Devices; public: const std::unordered_map\u003cstd::string, std::vector\u003cDevice *\u003e\u003e \u0026GetDevices() const { return m_Devices; } }; int main() { DeviceManager dm; const std::unordered_map\u003cstd::string, std::vector\u003cDevice *\u003e\u003e \u0026devices = dm.GetDevices();//不使用auto const auto\u0026 devices = dm.GetDevices(); //使用auto std::cin.get(); } 当类型名过长的时候可以使用using或者typedef： using DeviceMap = std::unordered_map\u003cstd::string, std::vector\u003cDevice*\u003e\u003e; typedef std::unordered_map\u003cstd::string, std::vector\u003cDevice*\u003e\u003e DeviceMap; ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:32","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++静态数组 stl库的一部分，创建时指定大小，长度不可变； #include \u003carray\u003e // 先要包含头文件int main() { std::array\u003cint, 5\u003e data; //定义，有两个参数，一个指定类型，一个指定大小 data[0] = 1; data[4] = 10; return 0; } array和原生数组都是创建在栈上的（vector是在堆上创建底层数据储存的）(这里是指数组控制的内存在哪里而不是对象存放在哪里，比如一个vector数组在栈上创建，那么这个对象就在栈上，但是指向堆中的一系列内存) 原生数组越界的时候不会报错，而array会有越界检查，会报错提醒，且array可以访问大小。 #include\u003ciostream\u003e#include\u003carray\u003e void PrintArray(const std::array\u003cint, 5\u003e\u0026 data) //指定大小 { for (int i = 0;i \u003c data.size();i++) //访问大小 { std::cout \u003c\u003c data[i] \u003c\u003c std::endl; } } int main() { std::array\u003cint, 5\u003e data; data[0] = 0; data[1] = 1; data[2] = 2; data[3] = 3; data[4] = 4; PrintArray(data); std::cin.get(); } } 传入未知大小的array数组作为参数（cherno的问答） #include \u003ciostream\u003e#include \u003carray\u003e//其实这里是未知大小，未知类型，都用模板处理 template \u003ctypename T\u003e void printarray(const T \u0026data) { for (int i = 0; i \u003c data.size(); i++) { std::cout \u003c\u003c data[i] \u003c\u003c std::endl; } } template \u003ctypename T, unsigned long N\u003e // or // template \u003ctypename T, size_t N\u003e void printarray2(const std::array\u003cT, N\u003e \u0026data) { for (int i = 0; i \u003c N; i++) { std::cout \u003c\u003c data[i] \u003c\u003c std::endl; } } int main() { std::array\u003cint, 5\u003e data; data[0] = 2; data[4] = 1; printarray(data); printarray2(data); } //代码参考：https://github.com/UrsoCN/NotesofCherno/blob/main/Cherno57.cpp ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:33","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++的函数指针 函数实际上是CPU的指令，本质是二进制文件，可以获取这些二进制文件的地址，即函数指针 void HelloWorld() { std::cout\u003c\u003c\"hello\"\u003c\u003cstd::endl; } int main() { auto function = \u0026HelloWorld; // \u0026 可省略,其中的 function 可自定义 //function的类型为 void(*function)() function(); std::cin.get(); } function的类型为 void(*function)() 有传参时，且用typedef替换时： void HelloWorld(int a) { std::cout\u003c\u003c\"value: \"\u003c\u003ca\u003c\u003cstd::endl; } int main() { typedef void(*HelloFunction)(int); HelloFunction function = HelloWorld; function(5); std::cin.get(); } 函数指针的用法：可以作为形参传入另一个函数并使用。 void PrintValue(int value) { std::cout\u003c\u003cvalue\u003c\u003cstd::endl; } void ForEach(const std::vector\u003cint\u003e\u0026 values, void(*func)(int)) { for (int value : values) { func(value); } } int main() { std::vector\u003cint\u003e values = {1,2,3,4,5}; ForEach(values,PrintValue); std::cin.get(); } lambda表达式：一种匿名的，用完即弃的，在过程中生成的函数； 格式：[] ({形参表}) {函数内容} void ForEach(const std::vector\u003cint\u003e\u0026 values, void(*function)(int)) { for (int temp : values) { function(temp); //正常调用lambda函数 } } int main() { std::vector\u003cint\u003e valus = { 1, 2, 3, 4, 5 }; ForEach(values, [](int val){ std::cout \u003c\u003c val \u003c\u003c std::endl; }); //如此简单的事就交给lambda来解决就好了 } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:34","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中的lambda 在使用函数指针的时候就可以考虑使用lambda表达式，作为函数指针传入某些函数，如此处的std::findif 可以捕获外面的变量，或直接调用lambda函数 int main() { std::vector\u003cint\u003e array = {1,2,3,4,5}; //find_if是一个搜索类的函数，区别于find的是：它可以接受一个函数指针来定义搜索的规则，返回满足这个规则的第一个元素的迭代器。 auto it = std::find_if(array.begin(),array.end(),[](int v){return v \u003e 3;}); std::cout\u003c\u003c*it\u003c\u003cstd::endl; std::string s = \"value:\"; auto lambda = [=](int value) {std::cout \u003c\u003c s \u003c\u003c value\u003c\u003c std::endl; }; lambda(10); std::cin.get(); } //如果使用捕获,则： //添加头文件： #include \u003cfunctional\u003e //修改相应的函数签名 std::function \u003cvoid(int)\u003e func替代 void(*func)(int) //捕获[]使用方式： //[=]，则是将所有变量值传递到lambda中 //[\u0026]，则是将所有变量引用传递到lambda中 //[a]是将变量a通过值传递，如果是[\u0026a]就是将变量a引用传递 //它可以有0个或者多个捕获 //用法详情：https://en.cppreference.com/w/cpp/language/lambda 使用mutable，允许lambda函数体修改通过拷贝传递捕获的参数 int a = 5; auto lambda = [=](int value) mutable { a = 5; std::cout \u003c\u003c \"Value: \" \u003c\u003c value \u003c\u003c a \u003c\u003c std::endl; }; ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:35","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"为什么不使用 using namespace std 会难以区分各种函数或者类的来源是否为标准库，且编译器可能无法区分 绝不在头文件中使用 using namespace std，防止他人引用时出现冲突，产生难以最终的错误 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:36","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++的命名空间namespace 相比于c，c++具有命名空间，避免了命名冲突 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003calgorithm\u003enamespace apple { void print(const char *text) { std::cout \u003c\u003c text \u003c\u003c std::endl; } } namespace orange { void print(const char *text) { std::string temp = text; std::reverse(temp); std::cout \u003c\u003c temp \u003c\u003c std::endl; } } int main() { //using namespace apple::print; //单独引出一个print函数 //using namespace apple;//引出apple名称空间的所有成员 apple::print(\"hello\"); //输出正常text orange::print(\"world\"); //输出反转的text } 命名空间可以嵌套，在c++新标准中使用inline内联命名空间可以代替嵌套，不需要使用using语句就可以直接在外层命名空间使用该命名空间内部的内容，而且无需使用命名空间前缀 namespace foo { namespace bar { class Cat { /*...*/ }; } } // 调用方式 foo::bar::Cat //新标准-------------------------------------------------------------------------------------------------- inline namespace FifthEd { // ... } 后续再打开命名空间的时候可以写inline也可以不写 namespace FifthEd { // ... } // 两处声明的命名空间同名，它们同属一个命名空间，inline必须出现在命名空间第一次出现的地方，后续再打开命名空间的时候可以写inline也可以不写，为隐式内敛 //直接使用foo::调用成员 命名空间可以匿名，几个匿名的命名空间互相独立，且作用域与其所在的作用域相同，故应注意避免冲突 // i的全局声明 int i; // i在未命名的命名空间中的声明 namespace { int i; } // 二义性错误: i的定义既出现在全局作用域中, 又出现在未嵌套的未命名的命名空间中 i = 10; （未命名的命名空间取代文件中的静态声明： 在标准C++引入命名空间的概念之前，程序需要将名字声明成static的以使其对于整个文件有效。在文件中进行静态声明的做法是从C语言继承而来的。在C语言中，声明为static的全局实体在其所在的文件外不可见。 在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命名的命名空间。） ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:37","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中的线程 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，进程包含一个或者多个线程。C++多线程使用多个函数实现各自功能，然后将不同函数生成不同线程，并同时执行这些线程（不同线程可能存在一定程度的执行先后顺序，但总体上可以看做同时执行 使用线程使得程序执行更加清晰，速度更快，在大型项目中十分重要。 c++多线程使用案例 #include\u003ciostream\u003e#include\u003cthread\u003estatic bool is_Finished = false; void DoWork() { using namespace std::literals::chrono_literals; // 为 1s 提供作用域 std::cout \u003c\u003c \"Started thread ID: \"\u003c\u003cstd::this_thread::get_id()\u003c\u003cstd::endl; while (!is_Finished) { std::cout\u003c\u003c\"Working...\"\u003c\u003cstd::endl; std::this_thread::sleep_for(1s);//等待1s } } int main() { std::thread worker(DoWork);//创建线程 std::cin.get(); // 同时阻塞主线程 is_Finished = true;// 让worker线程终止的条件 worker.join();// 让主线程等待worker线程结束后继续执行 std::cout \u003c\u003c \"Finished thread ID: \" \u003c\u003c std::this_thread::get_id() \u003c\u003c std::endl; std::cin.get(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:38","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++的计时 c++可以使用计时来监控程序执行的时间，对象生存的时间，评判算法优劣等等。 计时有两种选择，一种是用平台特定的API，另一种是用std::chrono（推荐）;建立一个Timer类，分别在其构造函数和析构函数中显示时间并计算出时间差，以此记录此作用域的生存时间： struct Timer //写一个计时器类。 { std::chrono::time_point\u003cstd::chrono::steady_clock\u003e start, end; std::chrono::duration\u003cfloat\u003e duration; Timer() { start = std::chrono::steady_clock::now(); //如果使用auto关键字会出现警告 } ~Timer() { end = std::chrono::steady_clock::now(); duration = end - start; float ms = duration.count() * 1000; std::cout \u003c\u003c \"Timer took \" \u003c\u003c ms \u003c\u003c \" ms\" \u003c\u003c std::endl; } }; void Function() { Timer timer; for (int i = 0; i \u003c 100; i++) std::cout \u003c\u003c \"Hello\\n\"; //相比于std::endl更快 } int main() { Function(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:39","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++多维数组 实质上就是在堆上分配空间，储存指针的指针的指针（指针*N）即n维数组(这些指针均为数组的首地址) int* array = new int[50];//一维 int** a2d = new int* [50];//二维 int*** a3d = new int** [50];//三维 for (int i = 0; i \u003c 50; i++) a2s = new int[50]; for (int i = 0; i \u003c 50; i++) delete[] a2d[i]; delete[] a2d; //删除多维数组一定要小心，必须在每一维中分别删除，避免仅仅删除一维的而造成内存泄漏 由于在堆上分配空间，基本上不会是连续的内存，因此多维数组的性能往往不如一维数组 优化：把二维数组转化成一维数组来进行存储(多维数组) int *array = new int[6 * 5]; //模拟二维 for (int y = 0; y \u003c 5; y++) //数组优化，将二维数组转化为一维数组 { for (int x = 0; x \u003c 6; x++) { array[y * 5 + x] = 2; } } std::cin.get(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:40","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++内置的排序函数 sort( vec.begin(), vec.end(), 谓语) 此处谓语用于指明排序方法（若无谓语默认升序），谓语可以是lambda表达式或者内置函数 #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003calgorithm\u003e#include\u003cfunctional\u003e int main() { std::vector\u003cint\u003e values = {3, 5, 1, 4, 2}; std::sort(values.begin(), values.end(),std::greater\u003cint\u003e()); //内置函数 std::sort(values.begin(), values.end(), [](int a, int b) { return a \u003c b; });//lambda表达式，其中参数a，b按次序前后对应 for (int value : values) std::cout \u003c\u003c value \u003c\u003c std::endl; // 5 4 3 2 1 std::cin.get(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:41","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++的类型双关(type punning) 将同一块内存的东西通过不同type的指针给取出来. #include \u003ciostream\u003eint main() { int a = 50; double value = *(double*)\u0026a;//此处产生了新的变量，但是也是拷贝了不属于原变量的未定义的多余4个字节 std::cout \u003c\u003c value \u003c\u003c std::endl; std::cin.get(); } //可以用引用，这样就可以避免拷贝成一个新的变量，这样更糟糕 #include \u003ciostream\u003eint main() { int a = 50; double\u0026 value = *(double*)\u0026a; std::cout \u003c\u003c value \u003c\u003c std::endl; std::cin.get(); } 结构体的内存分布甚至可以看成数组,而指针的类型决定了地址的单位偏移量 #include \u003ciostream\u003estruct Entity { int x, y; }; int main() { Entity e = {5, 8}; int *position = (int *)\u0026e; std::cout \u003c\u003c position[0] \u003c\u003c \", \" \u003c\u003c position[1] \u003c\u003c std::endl; int y = *(int *)((char *)\u0026e + 4); std::cout \u003c\u003c y \u003c\u003c std::endl; } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:42","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++的联合体( union ) 使用方法union { };，结尾有分号。通常union是匿名使用的，但是匿名union不能含有成员函数 union的特点是共用内存 。可以像使用结构体或者类一样使用它们，也可以给它添加静态函数或者普通函数、方法等。 //案例 #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003calgorithm\u003estruct vec2 { float x,y; }; struct vec4 { union { struct { float x,y,z,w; }; struct { vec2 a,b; }; }; }; void PrintVec2(const vec2\u0026 vec) { std::cout\u003c\u003cvec.x\u003c\u003c\",\"\u003c\u003cvec.y\u003c\u003cstd::endl; } int main() { vec4 vector = {1.0f,2.0f,3.0f,4.0f}; PrintVec2(vector.a); // 输出 1，2 PrintVec2(vector.b); // 输出 3，4 vector.z = 10.0f; PrintVec2(vector.a); // 输出 1，2 PrintVec2(vector.b); // 输出 10，4 std::cin.get(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:43","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++的虚析构函数 用子类创建对象定义父类对象，必须指明父类对象的析构函数是virtual的（即指明还会有一个析构函数需要被调用），否则在析构时只会调用父类析构函数，不会调用子类虚构函数，此时很可能会造成内存泄漏（子类虚构函数的工作未完成，内存未释放） #include \u003ciostream\u003e class Base { public: Base() { std::cout \u003c\u003c \"Base Constructor\\n\"; } virtual ~Base() { std::cout \u003c\u003c \"Base Destructor\\n\"; } }; class Derived : public Base { public: Derived() { m_Array = new int[5]; std::cout \u003c\u003c \"Derived Constructor\\n\"; } ~Derived() { delete[] m_Array; std::cout \u003c\u003c \"Derived Destructor\\n\"; } private: int *m_Array; }; int main() { Base *base = new Base(); delete base; std::cout \u003c\u003c \"-----------------\" \u003c\u003c std::endl; Derived *derived = new Derived(); delete derived; std::cout \u003c\u003c \"-----------------\" \u003c\u003c std::endl; Base *poly = new Derived(); delete poly; // Base Constructor // Base Destructor // Base Constructor // Derived Constructor // Derived Destructor // Base Destructor // Base Constructor // Derived Constructor // Derived Destructor // Base Destructor } 引自B站评论区： 此处这位外国友人说错了，定义基类的虚析构并不是什么相加，而是：基类中只要定义了虚析构（且只能在基类中定义虚析构，子类析构才是虚析构，如果在二级子类中定义虚析构，编译器不认，且virtual失效），在编译器角度来讲，那么由此基类派生出的所有子类地析构均为对基类的虚析构的重写，当多态发生时，用父类引用，引用子类实例时，此时的虚指针保存的子类虚表的地址，该函数指针数组中的第一元素永远留给虚析构函数指针。所以当delete 父类引用时，即第一个调用子类虚表中的子类重写的虚析构函数此为第一阶段。然后进入第二阶段：（二阶段纯为内存释放而触发的逐级析构与虚析构就没有半毛钱关系了）而当子类发生析构时，子类内存开始释放，因内存包涵关系，触发父类析构执行，层层向上递进，至到子类所包涵的所有内存释放完成。 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:44","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中的类型转换 c++四种类型转换：static_cast dynamic_cast reinterpret_cast const_cast static_cast用于进行比较“自然”和低风险的转换，如整型和浮点型、字符型之间的互相转换,不能用于指针类型的强制转换 double dPi = 3.1415926; int num = static_cast\u003cint\u003e(dPi); //num的值为3 double d = 1.1; void *p = \u0026d; double *dp = static_cast\u003cdouble *\u003e(p); reinterpret_cast 用于进行各种不同类型的指针之间强制转换,通常为运算对象的位模式提供较低层次上的重新解释。 int *ip; char *pc = reinterpret_cast\u003cchar *\u003e(ip); const_cast 添加或者移除const性质 注：这种const必须为底层const（例如常量指针是一个底层const，指向可改，指向的值不可改；指针常量是一个顶层const，指针指向不可改，指向的值可改） const string \u0026shorterString(const string \u0026s1, const string \u0026s2) { return s1.size() \u003c= s2.size() ? s1 : s2; } //上面函数返回的是常量string引用，当需要返回一个非常量string引用时，可以增加下面这个函数 string \u0026shorterString(string \u0026s1, string \u0026s2) //函数重载 { auto \u0026r = shorterString(const_cast\u003cconst string \u0026\u003e(s1), const_cast\u003cconst string \u0026\u003e(s2)); return const_cast\u003cstring \u0026\u003e(r); } dynamic_cast 安全地在继承体系里面向上、向下或横向转换指针和引用的类型，多态转换；不检查转换安全性，仅运行时检查，如果不能转换，返回NULL #include \u003ciostream\u003eclass Base { public: Base() { std::cout \u003c\u003c \"Base Constructor\\n\"; } virtual ~Base() { std::cout \u003c\u003c \"Base Destructor\\n\"; } }; class Derived : public Base { public: Derived() { m_Array = new int[5]; std::cout \u003c\u003c \"Derived Constructor\\n\"; } ~Derived() { delete[] m_Array; std::cout \u003c\u003c \"Derived Destructor\\n\"; } private: int *m_Array; }; class AnotherClass : public Base { public: AnotherClass(){}; ~AnotherClass(){}; }; int main() { // double value = 5.25; // // int a = value; // // int a = (int)value; // double a = (int)value + 5.3; // 10.3 // C style cast here // double s = static_cast\u003cint\u003e(value) + 5.3; // C++ style cast here // std::cout \u003c\u003c a \u003c\u003c std::endl; // std::cout \u003c\u003c s \u003c\u003c std::endl; Derived *derived = new Derived(); Base *base = derived; // AnotherClass *ac = static_cast\u003cAnotherClass*\u003e(base); //NULL Derived *ac = dynamic_cast\u003cDerived *\u003e(base); delete derived; } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:45","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++预编译头文件 在编译阶段，被引入的头文件每一次都要重新编译一遍，编译时间会很长。预编译头文件即是将头文件预先编译为二进制文件，如果头文件此后不需要修改，在编译时就直接用编译好的二进制文件，可以大大缩短编译时间。一些不大会改变的文件也可以放入预编译用于缩短运行时间。 流程：例子：//引用大佬的笔记，原链接在此Cherno的C++教学视频笔记（已完结） - 知乎 (zhihu.com) 新建一个工程和解决方案，添加Main.cpp,pch.cpp,pch.h三个文件，内容分别如下： // Main.cpp #include\"pch.h\" int main() { std::cout\u003c\u003c\"Hello!\"\u003c\u003cstd::endl; std::cin.get(); } // pch.cpp #include\"pch.h\"// pch.h #pragma once #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003cmemory\u003e#include\u003cstring\u003e#include\u003cthread\u003e#include\u003cchrono\u003e#include\u003cunordered_map\u003e#include\u003cWindows.h\u003e 在pch.cpp右键，属性-配置属性-C/C++-预编译头-预编译头，里面选择创建, 并在下一行预编译头文件里面添加 pch.h 在项目名称上右键，属性-配置属性-C/C++-预编译头-预编译头，里面选择使用，并在下一行预编译头文件里面添加 pch.h 打开计时工具：工具-选项-项目和解决方案-VC++项目设置-生成计时，就可以看到每次编译的时间 进行对比： 进行预编译头文件前后的首次编译耗时分别为：2634ms和1745ms 进行预编译头文件前后的二次编译（即修改Main.cpp内容后）的耗时分别为：1235ms和312ms 可以看到进行预编译头文件后，时间大大降低 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:46","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++中的dynamic_cast 详解 dynamic_cast 安全地在继承体系里面向上、向下或横向转换指针和引用的类型，多态转换； 不检查转换安全性，仅运行时检查，如果不能转换，返回NULL dynamic_cast只用于多态类类型，即基类必须有虚函数或者说虚表 dynamic_cast使用了RTTI（运行时类型识别）,即存储了所有类型的运行时类型信息用与判断（也储存了更多自身的信息以及检查类型是否匹配所以会增加一些开销） #include\u003ciostream\u003eclass Base { public: virtual void print(){} }; class Player : public Base { }; class Enemy : public Base { }; int main() { Player* player = new Player(); Base* base = new Base(); Base* actualEnemy = new Enemy(); Base* actualPlayer = new Player(); // c风格 Base* pb1 = player; // 隐式转换 Player* bp1 = (Player*)base; // 显式转换，危险 Enemy* pe1 = (Enemy*)player; // 显式转换，危险 // dynamic_cast Base* pb2 = dynamic_cast\u003cBase*\u003e(player); Player* bp2 = dynamic_cast\u003cPlayer*\u003e(base); // 返回NULL Enemy* pe2 = dynamic_cast\u003cEnemy*\u003e(player); // 同级转换，失败返回NULL Player* aep = dynamic_cast\u003cPlayer*\u003e(actualEnemy); // 同级转换，失败返回NULL Player* app = dynamic_cast\u003cPlayer*\u003e(actualPlayer); // 成功 //转换结果可作为判断条件 if(bp2) { } } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:47","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++的基准测试 使用进行计时以进行基准测试，衡量代码的优劣 #include \u003ciostream\u003e#include \u003cmemory\u003e#include \u003cchrono\u003e #include \u003carray\u003eclass Timer { public: Timer() { m_StartTimePoint = std::chrono::high_resolution_clock::now();//启动定时器的时间 } ~Timer() { Stop(); } void Stop() { auto endTimePoint = std::chrono::high_resolution_clock::now();//停止定时器的时间 auto start = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(m_StartTimePoint).time_since_epoch().count(); //microseconds 将数据转换为微秒 //time_since_epoch() 测量自时间起始点到现在的时长 auto end = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(endTimePoint).time_since_epoch().count(); auto duration = end - start; double ms = duration * 0.001; ////转换为毫秒数 std::cout \u003c\u003c duration \u003c\u003c \"us(\" \u003c\u003c ms \u003c\u003c \"ms)\\n\"; } private: std::chrono::time_point\u003cstd::chrono::high_resolution_clock\u003e m_StartTimePoint; }; int main() { struct Vector2 { float x, y; }; { std::array\u003cstd::shared_ptr\u003cVector2\u003e, 1000\u003e sharedPtrs; Timer timer; for (int i = 0; i \u003c sharedPtrs.size(); i++) { sharedPtrs[i] = std::make_shared\u003cVector2\u003e(); } } { std::array\u003cstd::shared_ptr\u003cVector2\u003e, 1000\u003e sharedPtrs; Timer timer; for (int i = 0; i \u003c sharedPtrs.size(); i++) { sharedPtrs[i] = std::shared_ptr\u003cVector2\u003e(new Vector2()); } } { Timer timer; std::array\u003cstd::unique_ptr\u003cVector2\u003e, 1000\u003e sharedPtrs; for (int i = 0; i \u003c sharedPtrs.size(); i++) { sharedPtrs[i] = std::make_unique\u003cVector2\u003e(); } } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:48","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++的结构化绑定(Structured Binding)(c++17) 结构化绑定是c++17的新特性，可以用于处理多返回值，可以将tuple、pair、struct结构的成员直接返回，而不是返回结构。这样返回多值时无需创建新的结构，更加清晰简便。 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003ctuple\u003e std::tuple\u003cstd::string, int\u003e CreatPerson() { return {\"Cherno\", 24}; } int main() { auto[name, age] = CreatPerson(); std::cout \u003c\u003c name; ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:49","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"如何处理optional数据(std::optional)(c++17) std::optional类型可以是某类型的对象，也可以是什么都没有。有一种应用情况是，使用optional来判断读取文件是否成功。 //判断文件是否读取成功： //不使用optional：---------------------------------------------------------------------------------------- #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003cstring\u003estd::string ReadFile(const std::string \u0026filepath, bool \u0026outSuccess) { std::ifstream stream(filepath); if (stream) { std::string result; getline(stream,result); stream.close(); outSuccess = true; return result; } outSuccess = false; return std::string(); } //通过修改bool值来判断是否读取成功 int main() { bool flag; auto data = ReadFile(\"data.txt\", flag); if (flag) { } } //使用optional------------------------------------------------------------------------------------------- #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003coptional\u003e#include \u003cstring\u003e std::optional\u003cstd::string\u003e ReadFileAsString(const std::string\u0026 filepath) { std::ifstream stream(filepath); if (stream) { std::string result; getline(stream, result); stream.close(); return result; } return {};//返回一个optional空值 } int main() { std::optional\u003cstd::string\u003e data = ReadFileAsString(\"data.txt\"); if (data.has_value()) { std::cout \u003c\u003c \"File read successfully!\" \u003c\u003c data.value() \u003c\u003c std::endl; } else { std::cout \u003c\u003c \"File could not be opened!\" \u003c\u003c std::endl; } std::cin.get(); //或者使用value_or()方法 //std::string result = data.value_or(\"Not resprent\");(自定义默认值输出) //std::cout\u003c\u003cresult\u003c\u003cstd::endl; //std::cin.get(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:50","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"单一变量存放多种类型的数据std::variant（c++17） 相比union，variant更加类型安全，不会造成未定义行为，它和结构体十分类似，实际占用内存要比union大 std::variantt的大小是所有属性大小之和，而union的大小是最大属性大小。 #include\u003ciostream\u003e#include\u003cvariant\u003eint main() { std::variant\u003cstd::string,int\u003e data; // \u003c\u003e里面的类型不能重复 data = \"cherno\"; // 索引的第一种方式：std::get，但是要与上一次赋值类型相同，不然会报错 std::cout\u003c\u003cstd::get\u003cstd::string\u003e(data)\u003c\u003cstd::endl; // 索引的第二种方式，std::get_if，传入地址，会返回为指针 //也可以使用index()来判断当前索引属性 if (auto value = std::get_if\u003cstd::string\u003e(\u0026data)) { std::string\u0026 v = *value; } data = 2; std::cout\u003c\u003cstd::get\u003cint\u003e(data)\u003c\u003cstd::endl; std::cin.get(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:51","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++如何存储任意类型的数据(std::any)（c++17） 也是C++17引入的可以存储多种类型变量的结构，但是不像std::variant那样需要列出类型 就运行机制来说，对于小类型(small type)，any将它们存储为一个严格对齐的Union， 对于大类型，会用void*，动态分配内存 any一般很少用。 include \u003ciostream\u003e #include \u003cany\u003e// 这里的new的函数，是为了设置一个断点，通过编译器观察主函数中何处调用了new，看其堆栈。 void *operator new(size_t size) { return malloc(size); } int main() { std::any data; data = 2; data = \"Cherno\"; data = std::string(\"Cherno\"); std::string\u0026 string = std::any_cast\u003cstd::string\u0026\u003e(data); //用any_cast指定转换的类型,如果这个时候any不是想要转换的类型，则会抛出一个类型转换的异常 // 通过引用减少复制操作，以免影响性能 } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:52","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"如何让C++运行得更快(std::async) 使用std::async封装异步编程 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:53","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"如何让C++字符串更快(std::string_view) std::string以及他的许多函数都习惯在堆上分配内存，这会降低程序的速度。 #include\u003ciostream\u003e#include\u003cstring\u003estatic uint32_t s_AllocCount = 0; //调试技巧：对new操作符进行重载，可以记录开辟内存的行为以及大小 void* operator new(size_t size) { s_AllocCount++; std::cout\u003c\u003c\"Allocing: \"\u003c\u003csize\u003c\u003c\" bytes\\n\"; return malloc(size); } void PrintName(const std::string\u0026 name) { std::cout\u003c\u003cname\u003c\u003cstd::endl; } int main() { std::string fullName = \"Yan Chernikov\"; std::string firstName = fullName.substr(0,4); std::string lastName = fullName.substr(5,8); PrintName(firstName); PrintName(lastName); std::cout\u003c\u003cs_AllocCount\u003c\u003c\" allocations\\n\"; std::cin.get(); } Allocing: 8 bytes //Allocing : 8 bytes //Allocing : 8 bytes //Yan //Cherno //3 allocations //此处分配了三处内存，可见std::string分配内存很频繁，注意：即使仅仅是引用操作都会开辟内存 使用c++17新特性string_view类型可以避免字符串开辟内存，它要做的类似于“观察”一个已经存在的字符串 #include\u003ciostream\u003e#include\u003cstring\u003estatic uint32_t s_AllocCount = 0; void* operator new(size_t size) { s_AllocCount++; std::cout\u003c\u003c\"Allocing: \"\u003c\u003csize\u003c\u003c\" bytes\\n\"; return malloc(size); } void PrintName(std::string_view name) { std::cout\u003c\u003cname\u003c\u003cstd::endl; } int main() { std::string fullName = \"Yan Chernikov\"; std::string_view firstName(fullName.c_str(),4); std::string_view lastName(fullName.c_str()+5,8); PrintName(firstName); PrintName(lastName); std::cout\u003c\u003cs_AllocCount\u003c\u003c\" allocations\\n\"; std::cin.get(); } //Allocing: 8 bytes //Yan //hernikov //1 allocations //仅仅分配一次 将std::string改为存粹的c风格字符串const char*后分配零次内存，再次优化 #include\u003ciostream\u003e#include\u003cstring\u003estatic uint32_t s_AllocCount = 0; void* operator new(size_t size) { s_AllocCount++; std::cout\u003c\u003c\"Allocing: \"\u003c\u003csize\u003c\u003c\" bytes\\n\"; return malloc(size); } void PrintName(std::string_view name) { std::cout\u003c\u003cname\u003c\u003cstd::endl; } int main() { const char* fullName = \"Yan Chernikov\"; std::string_view firstName(fullName,4);//删去.c_str() std::string_view lastName(fullName+5,8); PrintName(firstName); PrintName(lastName); std::cout\u003c\u003cs_AllocCount\u003c\u003c\" allocations\\n\"; std::cin.get(); } //Yan //hernikov //0 allocations //0次分配 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:54","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++的可视化基准测试(Chrome://tracing工具) Chrome://tracing，谷歌的一个调试工具，可以清晰地用可视化的方法展示代码运行的情况 cherno演示了具体操作方法，并使用宏定义控制计时代码的有效性，以及函数传参的自动化，以及多线程调试的具体方法 #pragma once #include \u003cstring\u003e#include \u003cchrono\u003e#include \u003calgorithm\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003cthread\u003e#include \u003ciostream\u003e struct ProfileResult { std::string Name; long long Start, End; uint32_t ThreadID; //线程ID }; struct InstrumentationSession { std::string Name; }; class Instrumentor//此类用于格式化一个json文件并将其写入一个文件 { private: InstrumentationSession* m_CurrentSession; std::ofstream m_OutputStream; int m_ProfileCount; public: Instrumentor() : m_CurrentSession(nullptr), m_ProfileCount(0) { } void BeginSession(const std::string\u0026 name, const std::string\u0026 filepath = \"results.json\")//指定文件名创建新文件 { m_OutputStream.open(filepath);//打开一个文件 WriteHeader();//写文件头 m_CurrentSession = new InstrumentationSession{ name }; } void EndSession() { WriteFooter();//写文件页脚 m_OutputStream.close(); delete m_CurrentSession; m_CurrentSession = nullptr; m_ProfileCount = 0; } void WriteProfile(const ProfileResult\u0026 result)//整个类的核心，用于单独写时间分析数据 { if (m_ProfileCount++ \u003e 0) m_OutputStream \u003c\u003c \",\"; std::string name = result.Name; std::replace(name.begin(), name.end(), '\"', '\\''); m_OutputStream \u003c\u003c \"{\"; m_OutputStream \u003c\u003c \"\\\"cat\\\":\\\"function\\\",\"; m_OutputStream \u003c\u003c \"\\\"dur\\\":\" \u003c\u003c (result.End - result.Start) \u003c\u003c ','; m_OutputStream \u003c\u003c \"\\\"name\\\":\\\"\" \u003c\u003c name \u003c\u003c \"\\\",\"; m_OutputStream \u003c\u003c \"\\\"ph\\\":\\\"X\\\",\"; m_OutputStream \u003c\u003c \"\\\"pid\\\":0,\"; m_OutputStream \u003c\u003c \"\\\"tid\\\":\" \u003c\u003c result.ThreadID \u003c\u003c \",\"; //多线程 m_OutputStream \u003c\u003c \"\\\"ts\\\":\" \u003c\u003c result.Start; m_OutputStream \u003c\u003c \"}\"; m_OutputStream.flush();//一旦输出更多json进入输入流就刷新，以防程序终止或崩溃而丢失数据 } void WriteHeader() { m_OutputStream \u003c\u003c \"{\\\"otherData\\\": {},\\\"traceEvents\\\":[\"; m_OutputStream.flush(); } void WriteFooter() { m_OutputStream \u003c\u003c \"]}\"; m_OutputStream.flush(); } static Instrumentor\u0026 Get() { static Instrumentor instance; return instance; } }; //Instrumentation（插桩）指注入代码进行分析 class InstrumentationTimer { public: InstrumentationTimer(const char* name) :m_Name(name),m_Stopped(false) { m_StartTimepoint = std::chrono::high_resolution_clock::now(); } void Stop() { auto endTimepoint = std::chrono::high_resolution_clock::now(); long long start = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(m_StartTimepoint).time_since_epoch().count(); long long end = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(endTimepoint).time_since_epoch().count(); std::cout \u003c\u003c m_Name \u003c\u003c \":\" \u003c\u003c (end - start) \u003c\u003c \"ms\"\u003c\u003cstd::endl; uint32_t threadID = std::hash\u003cstd:🧵:id\u003e{}(std::this_thread::get_id());//c++标准库使得作为一个整数取得线程ID十分困难，但是可以使用线程ID实现的一个hash函数转换 Instrumentor::Get().WriteProfile({ m_Name,start,end,threadID });//将线程id写入正确文件中 m_Stopped = true; } ~InstrumentationTimer() { if (!m_Stopped) { Stop(); } } private: const char* m_Name; //std::chrono::time_point_cast\u003cstd::chrono::milliseconds\u003e(m_StartTimepoint).time_since std::chrono::time_point\u003cstd::chrono::steady_clock\u003e m_StartTimepoint; bool m_Stopped; }; #define PROFILING 1//使用宏定义控制对于计时器代码的使用 #if PROFILING #define PROFILE_SCOPE(name) InstrumentationTimer timer##__LINE__(name) //可以宏定义#define PROFILE_FUNCTION() PROFILE_SCOPE(__FUNCTION__)以传入函数名进行替换，注意__FUNCTION__只传入函数名而非函数签名,因此相同函数的重载无效（函数签名应用__FUNCSIG__） //甚至可以在外面添加一个作用域，由于宏定义__FUNCSIG__，也可以得到作用域的命名空间 //总之，在想分析的地方使用宏定义，简洁清晰 #else #define PROFILE_SCOPE(name) #endif void Function1() { PROFILE_SCOPE(\"Function1\"); for (int i = 0; i \u003c 1000; i++) { std::cout \u003c\u003c \"hello world #\" \u003c\u003c i \u003c\u003c std::endl; } } void Function2() { PROFILE_SCOPE(\"Function2\");//那样这里即可直接替换为 PROFILE_FUNCTION()由预处理器直接完成而不需要传入字符串 for (int i = 0; i \u003c 1000; i++) { std::cout \u003c\u003c \"hello world #\" \u003c\u003c sqrt(i) \u003c\u003c std::endl; } } void RunBenchmarks() { PROFILE_SCOPE(\"RunBenchmarks\"); std::cout \u003c\u003c \"runbenchmarks...\\n\"; std::thread a([] {Function1(); });//使用lambda表达式，稍微改变benchmark，让其使用多线程 std::thread b([] {Function2(); }); a.join(); b.join(); } int main() { Instrumentor::Get().BeginSession(\"profile\"); RunBenchmarks(); Instrumentor::Get().EndSession(); std::cin.get(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:55","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++的单例模型 类存在的意义就是可以被多次实例化，但有时我们只想要一个单一实例，只有单一的数据集。然后可能会有一些功能，同时具备代表数据的类成员变量，代表对特定数据集执行操作的成员函数。 #include\u003ciostream\u003eclass Singleton { public: Singleton(const Singleton\u0026) = delete; // 删除拷贝复制函数 static Singleton\u0026 Get() { return s_Instance; } void Function(){}//单例模型可以实现功能，可以具有成员变量 private: Singleton(){} // 构造函数写为private，无法实例化 static Singleton s_Instance; }; Singleton Singleton::s_Instance; // 此处实例化 int main() { Singleton::Get().Function(); } 简单的随机数类的例子 #include\u003ciostream\u003eclass Random { public: Random(const Random\u0026) = delete; // 删除拷贝复制函数 static Random\u0026 Get() // 通过Get函数来获取唯一的一个实例 { static Random instance; // 此处实例化一次 return instance; } static float Float(){ return Get().IFloat();} // 调用内部函数 private: float IFloat() { return m_RandomGenerator; } // 函数实现放进private Random(){} float m_RandomGenerator = 0.5f; }; // 与namespace很像 namespace RandomClass { static float s_RandomGenerator = 0.5f; static float Float(){return s_RandomGenerator;} } int main() { float randomNum = Random::Float(); std::cout\u003c\u003crandomNum\u003c\u003cstd::endl; std::cin.get(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:56","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++的小字符串优化 VS中使用std::string时，若字符串size小于16则在release模式下不会在堆上分配内存，而是会在栈上缓存（debug模式下都会分配）。 #include\u003ciostream\u003evoid* operator new(size_t size) { std::cout\u003c\u003c\"Allocated: \"\u003c\u003csize\u003c\u003c\" bytes\\n\"; return malloc(size); } int main() { std::string longName = \"chernooooooooooo\"; std::string shortName = \"cherno\"; std::cin.get(); } //Allocated: 32 bytes ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:57","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"c++跟踪内存分配的简单方法 重写new和delete操作符函数，并在里面打印分配和释放了多少内存，也可在重载的这两个函数里面设置断点，通过查看调用栈即可知道什么地方分配或者释放了内存(注意这里重写的并不是表达式new和delete，二十向下分解的new和delete操作符，它们要做的是分配相关内存) void* operator new(size_t size) { std::cout \u003c\u003c \"Allocing \" \u003c\u003c size \u003c\u003c \" bytes\\n\"; return malloc(size); } void operator delete(void* memory, size_t size) { std::cout \u003c\u003c \"Free \" \u003c\u003c size \u003c\u003c \" bytes\\n\"; free(memory); } struct Entity { int x, y, z; }; int main() { { std::string name = \"cherno\"; } Entity* e = new Entity(); delete e; std::cin.get(); } 也可以写一个简单统计内存分配的类，在每次new的时候统计分配内存，在每次delete时统计释放内存，可计算出已经分配的总内存 #include\u003ciostream\u003estruct AllocationMertics { uint32_t TotalAllocated = 0; uint32_t TotalFreed = 0; uint32_t CurrentUsage() {return TotalAllocated - TotalFreed;} }; static AllocationMertics s_AllocationMetrics; void* operator new(size_t size) { s_AllocationMetrics.TotalAllocated+=size; return malloc(size); } void operator delete(void* memory, size_t size) { s_AllocationMetrics.TotalFreed += size; free(memory); } static void PrintMemoryUsage() { std::cout\u003c\u003c\"Memory usage: \"\u003c\u003cs_AllocationMetrics.CurrentUsage()\u003c\u003c\" bytes\\n\"; } int main() { PrintMemoryUsage(); { std::string name = \"cherno\"; PrintMemoryUsage(); } PrintMemoryUsage(); std::cin.get(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:58","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++的左值与右值(lvalue and rvalue) 左值是有某种存储支持的变量，右值是临时值 //最简单的例子 int main() { std::string firstName = \"Yan\"; std::string lastName = \"Chernikov\";//等号左右两边分别为左值和右值 std::string fullname = firstName + lastName;//等号左边是左值，而右边(firstName + lastName)整体是组成的一个右值（临时值） return 0; } 左值引用是什么： //简单例子 int GetValue() { return 10; } int main() { int i = GetValue();//函数作为右值，因为仅仅是返回一个“10”，他被赋给右值i GetValue() = 5;//错误; 显而易见右值赋给右值是错误的，编译器会提醒GetValue()必须是可修改的左值也就是非const的 return 0; } //那如果函数返回的是左值（有某种存储支持的变量）呢？这就引出什么是左值引用 int \u0026GetValue() { // 左值引用 static int value = 10; return value; } int main() { int i = GetValue(); GetValue() = 5;//由于函数返回左值，可以给它赋右值 return 0; } 非const左值引用只可接受左值，const左值引用可以同时接受左值和右值；为了接受右值，我们有右值引用，表示接受一个临时值的引用，它不可以接受左值 #include \u003ciostream\u003e void SetValue(int value) {} void PrintName(std::string \u0026name) { // 非const的左值引用只接受左值 std::cout \u003c\u003c \"[lvalue]\" \u003c\u003c name \u003c\u003c std::endl; } void PrintName(const std::string \u0026\u0026name) { // 右值引用不能绑定到左值 std::cout \u003c\u003c \"[rvalue]\" \u003c\u003c name \u003c\u003c std::endl; } int main() { SetValue(i); // 左值参数调用 SetValue(10); // 右值参数调用，当函数被调时，这个右值会被用来创建一个左值 // 关于const，const引用可以同时接受左值和右值 // int\u0026 a = 10; // 不能用左值作为右值的引用 const int \u0026a = 10; // 通过创建一个左值实现 std::string firstName = \"Yan\"; std::string lastName = \"Chernikov\"; std::string fullname = firstName + lastName; PrintName(fullname); // 接受左值 PrintName(firstName + lastName); // 接受右值 return 0; } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:59","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++持续集成（CI） CI(Continuous integration，中文意思是持续集成)是一种软件开发时间。持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。 2、主要讲解如何在linode租一个服务器，来运行Jenkins ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:60","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"static analyze 主要讲了一个工具PVS-studio的用法，可以static analyze代码 开源的推荐 clang-tidy 如何在VS Code中运行clang-tidy?： https://zhuanlan.zhihu.com/p/446084601 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:61","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++的参数计算顺序 在给函数传参时，参数计算顺序可能是无法确定的，不同编译器或c++版本给出的顺序是不同的，这里介绍了一个未确定行为的例子 #include\u003ciostream\u003evoid PrintSum(int a, int b) { std::cout\u003c\u003ca\u003c\u003c\"+\"\u003c\u003cb\u003c\u003c\"=\"\u003c\u003ca+b\u003c\u003cstd::endl; } int main() { int value = 0; PrintSum(value++,++value); //行为未定义 std::cin.get(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:62","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"C++移动语义 移动语义 很多时候我们只是单纯创建一些右值，然后赋给某个对象用作构造函数。这时候会出现的情况是：首先需要在main函数里创建这个右值对象，然后复制给这个对象相应的成员变量。 如果我们可以直接把这个右值变量移动到这个成员变量而不需要做一个额外的复制行为，程序性能就能提高 noexcept 指定符:指定函数是否抛出异常。 举例：void f() noexcept {};// 函数 f() 不抛出异常 #include\u003ciostream\u003eclass String { public: String() = default; String(const char* string) //构造函数 { printf(\"Created\\n\"); m_Size = strlen(string); m_Data = new char[m_Size]; memcpy(m_Data,string,m_Size); } String(const String\u0026 other) // 拷贝构造函数 { printf(\"Copied\\n\"); m_Size = other.m_Size; m_Data = new char[m_Size]; memcpy(m_Data,other.m_Data,m_Size); } String(String\u0026\u0026 other) noexcept // 右值引用拷贝，相当于移动，就是复制一次指针，原来的指针给nullptr { printf(\"Moved\\n\"); m_Size = other.m_Size; m_Data = other.m_Data; other.m_Size = 0; other.m_Data = nullptr; } ~String() { printf(\"Destroyed\\n\"); delete m_Data; } private: uint32_t m_Size; char* m_Data; }; class Entity { public: Entity(const String\u0026 name) : m_Name(name) { } Entity(String\u0026\u0026 name) : m_Name(std::move(name)) // std::move(name)也可以换成(String\u0026\u0026)name { } private: String m_Name; }; int main() { Entity entity(\"cherno\"); std::cin.get(); } //在实例化entity的时候，如果传入的是字符串常量（右值），则会调用拷贝的右值版本，避免了一次new，如果传入的是String（左值），则仍然会进行一次左值拷贝 ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:63","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"std::move与移动赋值操作符 使用std::move，返回一个右值引用，可以将本来的copy操作变为move操作(将一个已经存在的对象移动给另一个已经存在的对象) #include\u003ciostream\u003eclass String { public: String() = default; String(const char* string) { printf(\"Created\\n\"); m_Size = strlen(string); m_Data = new char[m_Size]; memcpy(m_Data, string, m_Size); } String(const String\u0026 other) { printf(\"Copied\\n\"); m_Size = other.m_Size; m_Data = new char[m_Size]; memcpy(m_Data, other.m_Data, m_Size); } String(String\u0026\u0026 other) noexcept { printf(\"Moved\\n\"); m_Size = other.m_Size; m_Data = other.m_Data; other.m_Size = 0; other.m_Data = nullptr; } ~String() { printf(\"Destroyed\\n\"); delete m_Data; } void Print() { for (uint32_t i = 0; i \u003c m_Size; ++i) printf(\"%c\", m_Data[i]); printf(\"\\n\"); } String\u0026 operator=(String\u0026\u0026 other) // 移动复制运算符重载 { printf(\"Moved\\n\"); if (this != \u0026other) { delete[] m_Data; m_Size = other.m_Size; m_Data = other.m_Data; other.m_Data = nullptr; other.m_Size = 0; } return *this; } private: uint32_t m_Size; char* m_Data; }; class Entity { public: Entity(const String\u0026 name) : m_Name(name) { } void PrintName() { m_Name.Print(); } Entity(String\u0026\u0026 name) : m_Name(std::move(name)) // std::move(name)也可以换成(String\u0026\u0026)name { } private: String m_Name; }; int main() { String apple = \"apple\"; String orange = \"orange\"; printf(\"apple: \"); apple.Print(); printf(\"orange: \"); orange.Print(); apple = std::move(orange); printf(\"apple: \"); apple.Print(); printf(\"orange: \"); orange.Print(); std::cin.get(); } //输出： Created Created apple: apple orange: orange Moved apple: orange orange: ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:64","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"自己实现一个简单的Array类 Array #include\u003ciostream\u003etemplate\u003ctypename T,size_t S\u003e class Array { public: constexpr int Size() const {return S;} // const放在成员函数后面，表示函数不能修改值；用constexpr来修饰表示返回值是常量字面值，可以被编译器优化 T\u0026 operator[](size_t index) {return m_Data[index]; } // 返回引用以对原数据进行修改 const T\u0026 operator[](size_t index) const {return m_Data[index]; } T* Data(){return m_Data;} // 返回数组本身，实际上是个指针，其地址等价于\u0026m_Data[0] const T* Data() const {return m_Data;} private: T m_Data[S]; }; int main() { Array\u003cint,5\u003e data; memset(\u0026data[0],0,data.Size()*sizeof(int)); data[2] = 2; for(size_t i = 0;i\u003cdata.Size();i++) std::cout\u003c\u003cdata[i]\u003c\u003cstd::endl; std::cin.get(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:65","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"自己实现一个简单的Vector类 Vector template\u003ctypename T\u003e class Vector { public: Vector() { // Alloc 2 memory ReAlloc(2); // 初始化构造的时候默认分类两个内存 } ~Vector() { delete [] m_Data; // 此处写的不完整，还需要释放每个元素的内存 } void PushBack(T\u0026\u0026 value) // 右值版本，用move { if(m_Size \u003e= m_Capacity) // 发现当前分配内存快要满的时候，再多分配一点内存 ReAlloc(m_Capacity + m_Capacity/2); m_Data[m_Size] = std::move(value); m_Size++; } void PushBack(const T\u0026 value) // 左值版本，用copy { if (m_Size \u003e= m_Capacity) ReAlloc(m_Capacity + m_Capacity / 2); m_Data[m_Size] = value; m_Size++; } template\u003ctypename... Args\u003e T\u0026 EmplaceBack(Args\u0026\u0026... args) // Emplace与Push的区别在于，可以在里面调元素类的构造函数 { if(m_Size\u003e= m_Capacity) ReAlloc(m_Capacity+m_Capacity/2); new(\u0026m_Data[m_Size]) T(std::forward\u003cArgs\u003e(args)...); // 这句话看不太懂 // m_Data[m_Size] = T(std::forward\u003cArgs\u003e(args)...); //可替代上一句话 return m_Data[m_Size++]; } void PopBack() { if (m_Size \u003e 0) { m_Size--; m_Data[m_Size].~T(); // 弹出末尾元素，并且释放内存 } } void Clear() { for(size_t i = 0;i\u003cm_Size;i++) m_Data[i].~T(); m_Size = 0; } size_t Size() const { return m_Size;} const T\u0026 operator[] (size_t index) const { return m_Data[index]; } T\u0026 operator[] (size_t index) { return m_Data[index]; } private: void ReAlloc(size_t newCapacity) { // 1. alloc a new block of memory // 2. copy/move old elements to new block of memory // 3. delete T* newBlock = new T[newCapacity]; if(m_Size \u003e newCapacity) m_Size = newCapacity; for(size_t i = 0;i\u003cm_Size;i++) newBlock[i] = std::move(m_Data[i]); // 使用move的方式，避免copy delete[] m_Data; m_Data = newBlock; m_Capacity = newCapacity; } T* m_Data = nullptr; size_t m_Size; size_t m_Capacity; }; ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:66","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"iterator iterator可用于有序或者无序结构的遍历，如： #include\u003ciostream\u003e#include\u003cunordered_map\u003eint main() { typedef std::unordered_map\u003cstd::string,int\u003e ScoreMap; ScoreMap map; map[\"ydc\"] = 1; map[\"tt\"] = 2; for (ScoreMap::iterator it = map.begin(); it != map.end(); it++) { auto\u0026 key = it-\u003efirst; auto\u0026 value = it-\u003esecond; std::cout\u003c\u003ckey\u003c\u003c\"=\"\u003c\u003cvalue\u003c\u003cstd::endl; } for (auto\u0026 kv : map) // C++11引入的范围for循环 { auto\u0026 key = kv.first; auto\u0026 value = kv.second; std::cout \u003c\u003c key \u003c\u003c \"=\" \u003c\u003c value \u003c\u003c std::endl; } for(auto\u0026 [key,value]:map) // C++17引入的structure binding std::cout \u003c\u003c key \u003c\u003c \"=\" \u003c\u003c value \u003c\u003c std::endl; std::cin.get(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:67","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":["学习笔记"],"content":"自己写一个iterator类 主要是针对vector写一个iterator类，成员是一个指针，主要在iterator类里实现++,–,!=,[],-\u003e等操作符，以及在Vector类里面实现begin(),end()等成员函数： #include\u003ciostream\u003etemplate\u003ctypename Vector\u003e class VectorIterator { public: using ValueType = typename Vector::ValueType; // 此处要加上typename指出后面是一个类型名，以免引起歧义 using PointerType = ValueType*;// 这里可加可不加typename using ReferenceType = ValueType\u0026; public: VectorIterator(PointerType ptr):m_Ptr(ptr) {} VectorIterator operator++() { m_Ptr++; return *this; } VectorIterator operator++(int) // 这里看不懂 { VectorIterator iterator = *this; ++(*this); return iterator; } VectorIterator operator--() { m_Ptr--; return *this; } VectorIterator operator--(int) // 同++，也看不懂 { VectorIterator iterator = *this; --(*this); return iterator; } ReferenceType operator[](int index) { return *(m_Ptr+index); } PointerType operator-\u003e() // 不知道这里为啥返回一个指针 { return m_Ptr; } ReferenceType operator*() { return *m_Ptr; } bool operator==(const VectorIterator\u0026 other) const { return m_Ptr == other.m_Ptr; } bool operator!=(const VectorIterator\u0026 other) const { return !(*this==other); } private: PointerType m_Ptr; // 迭代器的一个主要成员就是一个指针 }; template\u003ctypename T\u003e class Vector { public: using ValueType = T; // 为了将此类型传给VectorIterator使用，故命名 using Iterator = VectorIterator\u003cVector\u003cT\u003e\u003e; // 用于begin和end函数返回类型 public: Vector() { // Alloc 2 memory ReAlloc(2); // 初始化构造的时候默认分类两个内存 } ~Vector() { delete[] m_Data; // 此处写的不完整，还需要释放每个元素的内存 } void PushBack(T\u0026\u0026 value) // 右值版本，用move { if (m_Size \u003e= m_Capacity) // 发现当前分配内存快要满的时候，再多分配一点内存 ReAlloc(m_Capacity + m_Capacity / 2); m_Data[m_Size] = std::move(value); m_Size++; } void PushBack(const T\u0026 value) // 左值版本，用copy { if (m_Size \u003e= m_Capacity) ReAlloc(m_Capacity + m_Capacity / 2); m_Data[m_Size] = value; m_Size++; } template\u003ctypename... Args\u003e T\u0026 EmplaceBack(Args\u0026\u0026... args) // Emplace与Push的区别在于，可以在里面调元素类的构造函数 { if (m_Size \u003e= m_Capacity) ReAlloc(m_Capacity + m_Capacity / 2); new(\u0026m_Data[m_Size]) T(std::forward\u003cArgs\u003e(args)...); // 这句话看不太懂 // m_Data[m_Size] = T(std::forward\u003cArgs\u003e(args)...); //可替代上一句话 return m_Data[m_Size++]; } void PopBack() { if (m_Size \u003e 0) { m_Size--; m_Data[m_Size].~T(); // 弹出末尾元素，并且释放内存 } } void Clear() { for (size_t i = 0; i \u003c m_Size; i++) m_Data[i].~T(); m_Size = 0; } Iterator begin() { return Iterator(m_Data); } Iterator end() { return Iterator(m_Data+m_Size); } size_t Size() const { return m_Size; } const T\u0026 operator[] (size_t index) const { return m_Data[index]; } T\u0026 operator[] (size_t index) { return m_Data[index]; } private: void ReAlloc(size_t newCapacity) { // 1. alloc a new block of memory // 2. copy/move old elements to new block of memory // 3. delete T* newBlock = new T[newCapacity]; if (m_Size \u003e newCapacity) m_Size = newCapacity; for (size_t i = 0; i \u003c m_Size; i++) newBlock[i] = std::move(m_Data[i]); // 使用move的方式，避免copy delete[] m_Data; m_Data = newBlock; m_Capacity = newCapacity; } T* m_Data = nullptr; size_t m_Size; size_t m_Capacity; }; int main() { Vector\u003cstd::string\u003e data; data.EmplaceBack(\"ydc\"); data.EmplaceBack(\"tt\"); for (Vector\u003cstd::string\u003e::Iterator it = data.begin(); it != data.end(); it++) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } for (auto\u0026 v : data) { std::cout\u003c\u003cv\u003c\u003cstd::endl; } std::cin.get(); } ","date":"2022-09-24","objectID":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/:2:68","tags":["编程语言"],"title":"cherno c++教程笔记","uri":"/%E5%AD%A6%E4%B9%A0cherno%E7%9A%84c-/"},{"categories":[],"content":"这是一个学生做的个人博客,因为一直以来觉得学的东西过一段时间很容易就了，所以习惯记录一些笔记。 但是原来记笔记都太散了，所以干脆建个博客来记录，回头有什么知识点要是忘了就可以再复习一下，此外学有余力情况下能分享和交流也是很好的。 ","date":"2022-07-07","objectID":"/about/:0:0","tags":[],"title":"About","uri":"/about/"},{"categories":["学习笔记"],"content":"排序 稳定性 (排序前A在B前B，排序后A=B，A仍在B前) 内排序（排序记录均放置在内存中）与外排序： 内排序性能: 时间性能：关键字比较次数及记录移动次数应尽可能少 辅助空间：存放待排序及算法运行所用空间 复杂性：算法复杂性影响排序性 #define MAXSIZE 10 //数组个数最大值 struct SqList{ int r[MAXSIZE+1];//储存要排序的数组 int length; } void swap(SqList *L,int i,int j){ int temp=L-\u003er[i]; L-\u003er[i]=L-\u003er[j]; L-\u003er[j]=temp; } ","date":"2022-06-08","objectID":"/sort/:0:0","tags":["数据结构"],"title":"关于排序","uri":"/sort/"},{"categories":["学习笔记"],"content":"排序种类 插入排序：好：0 moves, n-1 comparisons 坏：（n-1）n/2 moves 和comparisons n位swap 归并排序：T(n)=2*T([n/2])+cn 快速排序： 坏：（n-1）n/2 moves comparisons ","date":"2022-06-08","objectID":"/sort/:1:0","tags":["数据结构"],"title":"关于排序","uri":"/sort/"},{"categories":["学习笔记"],"content":"插入排序 直接插入排序：将一个记录插入到已知有序序列中。 void InsertSort(SqList *L) { for(int i=2;i\u003cL-\u003elength;i++) { if(L-\u003er[i]\u003cL-\u003er[i-1]) { L-\u003er[0]=L-\u003er[i];//哨兵r[0]用于存储需要插入的记录 for(int j=i-1;L-\u003er[j]\u003eL-\u003er[i];j--)//遍历必r[0]大的记录并后移 { L-\u003er[j+1]=L-\u003e[j]; } L-\u003er[j]=L-\u003er[0];//将数据r[0]放入空位 } } } 希尔排序：设定一个增量序列（质数序列，递减，最终为1），将以每一个增量作为间隔的少数记录做一次直接插入排序，由基本有序逐渐完善到整体有序。 void ShellSort(SqList *L) { int increment=L-\u003elength; do { increment=incrament/3+1; for(int i=increment+1;i\u003c=L-\u003elength;i++) { if(L-\u003er[i]\u003cL-\u003er[i-increment]) { L-\u003er[0]=L-\u003er[i]; for(int j=i-increment;j\u003e0\u0026\u0026L-\u003er[0]\u003cL-\u003er[j];j-=increment) { L-\u003er[j+increment]=L-\u003er[0]; } } } } while(increment\u003e1); } ","date":"2022-06-08","objectID":"/sort/:1:1","tags":["数据结构"],"title":"关于排序","uri":"/sort/"},{"categories":["学习笔记"],"content":"交换排序 冒泡排序： 快速排序：设计一个中心枢纽，枢纽左边的都是比他小的，右边的都是比他大的。左右边部分继续设置枢纽，进行排序，依此递归。 void QuickSort(SqList *L) { QSort(L,1,L-\u003elength); } void QSort(SqList *L,int low,int high) { int pivot; if(low\u003chigh) { pivot=Partition(L,low,high); QSort(L,low,pivot-1); QSort(L,pivot+1,high); } } int Partition(SqList *L,int low,int high) { int pivotKey; pivotkey=L-\u003er[low]; L-\u003er[0]=pivotkey; while(low\u003chigh) { while(low\u003chigh\u0026\u0026L-\u003er[high]\u003e=pivotkey){high--;} L-\u003er[low]=L-\u003er[high]; while(low\u003ehigh\u0026\u0026L-\u003e[low]\u003c=pivotkey){low++} L-\u003er[high]=L-\u003er[low]; } L-\u003er[llow]=L-\u003er[0]; return low; } ","date":"2022-06-08","objectID":"/sort/:1:2","tags":["数据结构"],"title":"关于排序","uri":"/sort/"},{"categories":["学习笔记"],"content":"选择排序 直接选择排序 void SelectSort(SqList *L) { int i,j,min; for(i=1;i\u003cL-\u003elength;i++) { min=i; for(j=i+1;j\u003cL-\u003elength;j++) { if(L-\u003er[j]\u003cL-\u003er[min]) { min=j; } } if(i!=min) { swap(L,min,i); } } } 堆排序 void HeapSort(SqList *L) { int i; for(i=L-\u003elength/2;i\u003e0;i--) { HeapAdjust(L,i,L-\u003elength); } for(i=L-\u003elength;i\u003e1;i--) { swap(L,1,i); HeapAdjust(L,1,i-1); } } void HeapAdjust(Aqlist *L,int s,int m) { int temp,j; temp=L-\u003er[s]; for(j=2*s;j\u003cm;j*=2) { if(j\u003cm \u0026\u0026 L-\u003er[j]\u003cL-\u003er[j+1]) { ++j; } if(temp\u003e=L-\u003er[j]) { break; } L-\u003er[s]=L-\u003er[j]; s=j; } L-\u003er[s]=temp; } ###　归并排序 void MergeSort(SqList *L) { MSort(L-\u003er,L-\u003er,1.L-\u003elength); } voidMSort(int SR[],int TR[],int s,int t) { int m; int TR2[MAXSIZE+1]; if(s==t) {TR1[s]=SR[s];} else { m=(s+t)/2; MSort(SR,TR,s,m); MSort(SR,TR,m+1,t); Merge(TR2,TR1,s,m,t); } } void Merge(int SR[],int TR[],int i,int m,int n) { if (SR[i]\u003cSR[j]) { TR[K]=SR[i++]; } else{TR[k]=SR[j++];} } if(i\u003c=m) { for(l=0;l\u003cm-i,l++ {TR[k+1]=SR[i+1];} } if(j\u003c=n) { for(l=0;l\u003cn-j,l++ {TR[k+1]=SR[i+1];} } ","date":"2022-06-08","objectID":"/sort/:1:3","tags":["数据结构"],"title":"关于排序","uri":"/sort/"},{"categories":["学习笔记"],"content":"简单介绍了网页的概念，记录了一些基本的HTML标签 ","date":"2022-06-08","objectID":"/html/:0:0","tags":["前端"],"title":"网页初识和基础HTML标签","uri":"/html/"},{"categories":["学习笔记"],"content":"网站与网页 网页是网站的一部分（网站是网页的集合），通常是HTML格式的文件，需要通过浏览器来阅读。 网页是构成网站的基本元素，通常由图片，链接，文字，声音，视频等元素组成。网页常是以.html或.htm后缀结尾的文件，因此俗称html文件。 （HTML：超文本标记语言，网页的标准语言。HTML并不是一门编程语言，而是一门描述性的标记语言） ","date":"2022-06-08","objectID":"/html/:1:0","tags":["前端"],"title":"网页初识和基础HTML标签","uri":"/html/"},{"categories":["学习笔记"],"content":"浏览器 五大浏览器：IE，谷歌，火狐，edge，sufari 浏览器内核（了解）： ","date":"2022-06-08","objectID":"/html/:2:0","tags":["前端"],"title":"网页初识和基础HTML标签","uri":"/html/"},{"categories":["学习笔记"],"content":"web标准 由w3c组织和其他标准化组织指定的一系列标准的集合，遵循web标准使得不同开发人员写出的页面更加统一。 web标准的构成（三者相互分离）： ","date":"2022-06-08","objectID":"/html/:3:0","tags":["前端"],"title":"网页初识和基础HTML标签","uri":"/html/"},{"categories":["学习笔记"],"content":"html标签: ","date":"2022-06-08","objectID":"/html/:4:0","tags":["前端"],"title":"网页初识和基础HTML标签","uri":"/html/"},{"categories":["学习笔记"],"content":"标签分类及结构 双标签： \u003chtml\u003e \u003c/html\u003e 单标签： \u003cbr /\u003e 包含关系 \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003c/head\u003e 并列关系 \u003chead\u003e\u003c/head\u003e \u003cbody\u003e\u003c/body\u003e 网页基本结构骨架： \u003c!DOCTYPE html\u003e//文档声明标签 \u003chtml lang=\"en\"\u003e//文档显示语言标签: \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e//通过\u003cmeta\u003e标签的chrset属性规定文档使用的字符编码方式 \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e用vscode创建网页\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e abababaababababab \u003c/body\u003e \u003c/html\u003e ","date":"2022-06-08","objectID":"/html/:4:1","tags":["前端"],"title":"网页初识和基础HTML标签","uri":"/html/"},{"categories":["学习笔记"],"content":"常用标签 标题标签 \u003ch1\u003e一级标题\u003c/h1\u003e \u003ch2\u003e二级标题\u003c/h2\u003e \u003ch3\u003e三级标题\u003c/h3\u003e \u003ch4\u003e四级标题\u003c/h4\u003e \u003ch5\u003e五级标题\u003c/h5\u003e \u003ch6\u003e六级标题\u003c/h6\u003e 段落与换行标签 (不同段落之间会有间隙，但强制换行没有间隙) \u003cp\u003e第一段阿巴阿巴\u003c/p\u003e \u003cp\u003e第二段阿巴阿巴\u003c/p\u003e \u003cp\u003e第二段(强制换行)\u003cbr/\u003e阿巴阿巴\u003c/p\u003e 文本格式化标签 \u003cstrong\u003e加粗1\u003c/strong\u003e \u003cb\u003e加粗2\u003c/b\u003e \u003cem\u003e倾斜1\u003c/em\u003e \u003ci\u003e倾斜2\u003c/i\u003e \u003cdel\u003e删除线1\u003c/del\u003e \u003cs\u003e删除线2\u003c/s\u003e \u003cins\u003e下划线1\u003c/ins\u003e \u003cu\u003e下划线2\u003c/u\u003e 注释标签 （ctrl+/）与特殊字符 \u003c!--此为注释--\u003e div和span标签 （无语义，用于布局） \u003cdiv\u003e第一个盒子，div独占一行\u003c/div\u003e \u003cspan\u003e第二个盒子，span可放多个\u003c/span\u003e \u003cspan\u003e第三个盒子\u003c/span\u003e 图像标签 (设置宽高时如果只改变一个则纵横比不变) \u003cimage src=\"文件路径2\" alt=\"此为图像无法显示时的替换文本\" title=\"鼠标移动到图片上的提示文本\" width=\"500\" height=\"100\" border=\"15\"/\u003e 超链接标签 （由一个页面链接到另一个页面） \u003c!----\u003ca herf=\"跳转的链接地址\" target=\"目标窗口的打开方式_self为默认模值，_blank为在新窗口打开\"\u003e文本或图像\u003c/a\u003e---\u003e \u003c!--1.外部链接:访问外部的qi'ta--\u003e \u003cbr/\u003e \u003ca href=\"http://www.baidu.com\" target=\"_blank\"\u003e百度\u003c/a\u003e \u003ca href=\"http://www.qq.com\"\u003e腾讯\u003c/a\u003e \u003c!--2.内部链接:访问网站内部的其他页面，直接链接内部页面名称即可--\u003e \u003ca href=\"vscode创建页面.html\"\u003e例子\u003c/a\u003e \u003c!--3.空链接:用于占位，链接地址为空--\u003e \u003ca href=\"#\"\u003e空链接\u003c/a\u003e \u003c!--4.下载链接:用于下载文件，可直接链接文件地址--\u003e \u003ca href=\"img.zip\"\u003e下载文件\u003c/a\u003e \u003c!--网页元素链接：链接的内容不仅仅可以是文字，也可以是其他的网页元素，如文本/表格/音频/视频--\u003e \u003ca href=\"http:www.baidu.com\"\u003e\u003cimg src=\"img.jpg\"/\u003e\u003c/a\u003e \u003c!--锚点链接:用于网页中某些位置的跳转，\u003c1\u003e.在href中设置#名字A\u003c2\u003e在目标位置标签中添加一个id属性=名字A--\u003e \u003ca href=\"#锚点1\"\u003e锚点一\u003c/a\u003e \u003ch3 id=\"锚点1\"\u003e锚点一详情\u003c/h3\u003e 表格标签 （用于显示数据） table标签创建表格，tr标签创建行，td标签创建相关单元格。对于表格第一行的单元格，使用th代替td作为表头标签进行突出 表格属性一般在css中进行设置，此处做了解 表格结构标签：由于表格可能很长，因此将表格分为头部与主体两大部分可以更好地表示表格语义 \u003c!-- 表格 --\u003e \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e\u003cth\u003e姓名\u003c/th\u003e \u003cth\u003e性别\u003c/th\u003e \u003cth\u003e年龄\u003c/th\u003e\u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e\u003ctd\u003eaa\u003c/td\u003e \u003ctd\u003e男\u003c/td\u003e \u003ctd\u003e11\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003ebb\u003c/td\u003e \u003ctd\u003e男\u003c/td\u003e \u003ctd\u003e12\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003ecc\u003c/td\u003e \u003ctd\u003e男\u003c/td\u003e \u003ctd\u003e15\u003c/td\u003e\u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 合并单元格（跨行colspan与跨列rowspan） 先找到目标单元格，按照跨行/列合并添加属性（数字代表合并单元格个数），再删掉多余行 \u003c!-- 合并单元格 --\u003e \u003ctable width=\"500\" heigth=\"249\" border=\"1\" cellspacing=\"0\"\u003e \u003cthead\u003e \u003ctr\u003e\u003cth\u003e姓名\u003c/th\u003e \u003cth\u003e性别\u003c/th\u003e \u003cth\u003e年龄\u003c/th\u003e\u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e\u003ctd\u003eaa\u003c/td\u003e \u003ctd colspan=\"2\"\u003e男\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd rowspan=\"2\"\u003ebb\u003c/td\u003e \u003ctd\u003e男\u003c/td\u003e \u003ctd\u003e12\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e男\u003c/td\u003e \u003ctd\u003e15\u003c/td\u003e\u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 列表标签 （用于布局页面） \u003c!-- 列表标签(相关属性在css中设置) --\u003e \u003c!-- 无序(ul中只可放li，li中可放其他元素) --\u003e \u003cul\u003e \u003cli\u003elll\u003c/li\u003e \u003cli\u003elol\u003c/li\u003e \u003cli\u003e\u003cp\u003e123\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e \u003c!-- 有序(了解,0l中只可放li，li中可放其他元素) --\u003e \u003col\u003e \u003cLI\u003eno.1\u003c/LI\u003e \u003cLI\u003eno.2\u003c/LI\u003e \u003cLI\u003eno.3\u003c/LI\u003e \u003c/ol\u003e \u003c!-- 自定义(dl中只可放dt或dd（个数不限），dd或dt中可放其他元素) --\u003e \u003cdl\u003e \u003cdt\u003e名词1\u003c/dt\u003e \u003cdd\u003e名词1解释1\u003c/dd\u003e \u003cdd\u003e名词1解释2\u003c/dd\u003e \u003c/dl\u003e 表单标签 （用于收集用户信息，由表单域form，表单控件（表单元素）及提示信息3部分组成） \u003c!-- 1.表单域标签\u003cform\u003e --\u003e \u003cform action=\"url地址\" method=\"提交方式\" name=\"表单域名称，用于区别不同表单\"\u003e \u003c/form\u003e \u003c!-- 2.表单元素标签 --\u003e \u003c!-- 2.1 input标签（不同type属性及其他属性） --\u003e \u003c!-- 文本框 --\u003e \u003c!-- value为值，规定了输入元素的值 --\u003e \u003c!-- maxlength规定了输入元素的最大长度 --\u003e 用户名：\u003cinput type=\"text\" name=\"username\" value=\"请输入用户名\" maxlength=\"4\"\u003e\u003cbr/\u003e \u003c!-- 密码框 --\u003e 密码：\u003cinput type=\"password\" name=\"pwd\" maxlength=\"6\"\u003e\u003cbr/\u003e \u003c!-- 单选和多选可设置checked属性，当页面打开时默认选中这个选项（多选中可以设置一个以上） --\u003e \u003c!-- 单选 --\u003e \u003c!-- name为表单元素的名字，此处单选name必须一致才可保证单选 --\u003e 性别：男\u003cinput type=\"radio\" name=\"sex\" checked=\"checked\"\u003e女\u003cinput type=\"radio\" name=\"sex\"\u003e\u003cbr/\u003e \u003c!-- 多选 --\u003e 爱好：吃饭\u003cinput type=\"checkbox\" name=\"hobby\" checked=\"checked\"\u003e睡觉\u003cinput type=\"checkbox\" name=\"hobby\" checked=\"checked\"\u003e喝水\u003cinput type=\"checkbox\" name=\"hobby\"\u003e\u003cbr/\u003e \u003c!-- 提交：将表单域中的值提交给后台服务器 --\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003c!-- 重置：将表单域中的值重置为初始状态 --\u003e \u003cinput type=\"reset\" value=\"重置\"\u003e \u003c!-- 普通按钮：可点击，用于通过js启动脚本 --\u003e \u003cinput type=\"button\" value=\"获取短信验证码\"\u003e \u003c!-- 文件域：用于上传文件 --\u003e 上传文件：\u003cinput type=\"file\"\u003e \u003c!-- 2.2 label标签(不是表单元素但常与input一起用)：用于绑定表单元素，点击标签内的文本，自动将光标转到对应的表单元素（for属性和对应元素id相同）上，用于优化用户体验 --\u003e 性别:\u003clabel for=\"sex\"\u003e男\u003c/label\u003e\u003cinput type=\"radio\" name=\"sex\" id=\"sex\"\u003e \u003c!-- 2.3 select标签：给用户提供下拉列表中的选项 --\u003e 籍贯： \u003cselect\u003e \u003coption\u003e北京\u003c/option\u003e \u003coption\u003e上海\u003c/option\u003e \u003coption\u003e深圳\u003c/option\u003e \u003coption selected=\"selected\"\u003e河南\u003c/option\u003e \u003c/select\u003e \u003c!-- 2.4 textarea文本域标签（其中的row和col一般在开发中不会使用，一般用css控制行列） --\u003e 文本域：\u003ctextarea rows=\"3\" cols=\"20\"\u003e这些是打开页面时默认的文本内容 \u003c/textarea\u003e 相对路径与绝对路径 相对路径：一引用文件夹所在位置为参考基础而建立的目录路径 绝对路径：指目录下的绝对位置，通常从盘符开始的路径 ","date":"2022-06-08","objectID":"/html/:4:2","tags":["前端"],"title":"网页初识和基础HTML标签","uri":"/html/"}]